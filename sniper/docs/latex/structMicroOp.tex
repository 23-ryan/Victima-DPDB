\doxysection{Micro\+Op Struct Reference}
\label{structMicroOp}\index{MicroOp@{MicroOp}}


{\ttfamily \#include $<$micro\+\_\+op.\+h$>$}



Collaboration diagram for Micro\+Op\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=231pt]{structMicroOp__coll__graph}
\end{center}
\end{figure}
\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \textbf{ uop\+\_\+type\+\_\+t} \{ \textbf{ UOP\+\_\+\+INVALID} = 0
, \textbf{ UOP\+\_\+\+LOAD}
, \textbf{ UOP\+\_\+\+EXECUTE}
, \textbf{ UOP\+\_\+\+STORE}
 \}
\item 
enum \textbf{ uop\+\_\+subtype\+\_\+t} \{ \newline
\textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+FP\+\_\+\+ADDSUB}
, \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+FP\+\_\+\+MULDIV}
, \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+LOAD}
, \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+STORE}
, \newline
\textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+GENERIC}
, \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+BRANCH}
, \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+SIZE}
 \}
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Micro\+Op} ()
\item 
void \textbf{ make\+Load} (\textbf{ uint32\+\_\+t} offset, dl\+::\+Decoder\+::decoder\+\_\+opcode \textbf{ instruction\+Opcode}, const String \&instruction\+Opcode\+Name, uint16\+\_\+t mem\+\_\+size)
\item 
void \textbf{ make\+Execute} (\textbf{ uint32\+\_\+t} offset, \textbf{ uint32\+\_\+t} num\+\_\+loads, dl\+::\+Decoder\+::decoder\+\_\+opcode \textbf{ instruction\+Opcode}, const String \&instruction\+Opcode\+Name, bool \textbf{ is\+Branch})
\item 
void \textbf{ make\+Store} (\textbf{ uint32\+\_\+t} offset, \textbf{ uint32\+\_\+t} num\+\_\+execute, dl\+::\+Decoder\+::decoder\+\_\+opcode \textbf{ instruction\+Opcode}, const String \&instruction\+Opcode\+Name, uint16\+\_\+t mem\+\_\+size)
\item 
void \textbf{ make\+Dynamic} (const String \&instruction\+Opcode\+Name, \textbf{ uint32\+\_\+t} exec\+Latency)
\item 
void \textbf{ set\+Types} ()
\item 
\textbf{ uop\+\_\+subtype\+\_\+t} \textbf{ get\+Subtype} (void) const
\item 
bool \textbf{ is\+Fp\+Load\+Store} () const
\item 
void \textbf{ set\+Is\+X87} (bool \+\_\+is\+\_\+x87)
\item 
bool \textbf{ is\+X87} (void) const
\item 
void \textbf{ set\+Operand\+Size} (int size)
\item 
uint16\+\_\+t \textbf{ get\+Operand\+Size} (void) const
\item 
uint16\+\_\+t \textbf{ get\+Memory\+Access\+Size} (void) const
\item 
void \textbf{ set\+Instruction} (\textbf{ Instruction} $\ast$instr)
\item 
\textbf{ Instruction} $\ast$ \textbf{ get\+Instruction} (void) const
\item 
void \textbf{ set\+Decoded\+Instruction} (const dl\+::\+Decoded\+Inst $\ast$instr)
\item 
const dl\+::\+Decoded\+Inst $\ast$ \textbf{ get\+Decoded\+Instruction} (void) const
\item 
dl\+::\+Decoder\+::decoder\+\_\+opcode \textbf{ get\+Instruction\+Opcode} () const
\item 
void \textbf{ set\+First} (bool \textbf{ first})
\item 
bool \textbf{ is\+First} () const
\item 
void \textbf{ set\+Last} (bool \textbf{ last})
\item 
bool \textbf{ is\+Last} () const
\item 
void \textbf{ verify} () const
\item 
\textbf{ uint32\+\_\+t} \textbf{ get\+Source\+Registers\+Length} () const
\item 
dl\+::\+Decoder\+::decoder\+\_\+reg \textbf{ get\+Source\+Register} (\textbf{ uint32\+\_\+t} index) const
\item 
void \textbf{ add\+Source\+Register} (dl\+::\+Decoder\+::decoder\+\_\+reg register\+Id, const String \&register\+Name)
\item 
\textbf{ uint32\+\_\+t} \textbf{ get\+Address\+Registers\+Length} () const
\item 
dl\+::\+Decoder\+::decoder\+\_\+reg \textbf{ get\+Address\+Register} (\textbf{ uint32\+\_\+t} index) const
\item 
void \textbf{ add\+Address\+Register} (dl\+::\+Decoder\+::decoder\+\_\+reg register\+Id, const String \&register\+Name)
\item 
\textbf{ uint32\+\_\+t} \textbf{ get\+Destination\+Registers\+Length} () const
\item 
dl\+::\+Decoder\+::decoder\+\_\+reg \textbf{ get\+Destination\+Register} (\textbf{ uint32\+\_\+t} index) const
\item 
void \textbf{ add\+Destination\+Register} (dl\+::\+Decoder\+::decoder\+\_\+reg register\+Id, const String \&register\+Name)
\item 
const \textbf{ Memory\+::\+Access} \& \textbf{ get\+Instruction\+Pointer} () const
\item 
void \textbf{ set\+Instruction\+Pointer} (const \textbf{ Memory\+::\+Access} \&ip)
\item 
bool \textbf{ is\+Branch} () const
\item 
bool \textbf{ is\+Interrupt} () const
\item 
void \textbf{ set\+Interrupt} (bool \textbf{ interrupt})
\item 
bool \textbf{ is\+Serializing} () const
\item 
void \textbf{ set\+Serializing} (bool \textbf{ serializing})
\item 
bool \textbf{ is\+Mem\+Barrier} () const
\item 
void \textbf{ set\+Mem\+Barrier} (bool membar)
\item 
bool \textbf{ is\+Cache\+Flush} () const
\item 
bool \textbf{ is\+Div} () const
\item 
bool \textbf{ is\+Pause} () const
\item 
bool \textbf{ is\+Load} () const
\item 
bool \textbf{ is\+Store} () const
\item 
void \textbf{ set\+Debug\+Info} (String debug\+Info)
\item 
String \textbf{ to\+String} () const
\item 
String \textbf{ to\+Short\+String} (bool with\+Disassembly=false) const
\item 
bool \textbf{ is\+Execute} () const
\item 
\textbf{ uop\+\_\+type\+\_\+t} \textbf{ get\+Type} () const
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \textbf{ uop\+\_\+subtype\+\_\+t} \textbf{ get\+Subtype\+\_\+\+Exec} (const \textbf{ Micro\+Op} \&uop)
\item 
static \textbf{ uop\+\_\+subtype\+\_\+t} \textbf{ get\+Subtype} (const \textbf{ Micro\+Op} \&uop)
\item 
static String \textbf{ get\+Subtype\+String} (\textbf{ uop\+\_\+subtype\+\_\+t} \textbf{ uop\+\_\+subtype})
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\textbf{ uop\+\_\+type\+\_\+t} \textbf{ uop\+\_\+type}
\item 
\textbf{ uop\+\_\+subtype\+\_\+t} \textbf{ uop\+\_\+subtype}
\item 
bool \textbf{ first}
\item 
bool \textbf{ last}
\item 
dl\+::\+Decoder\+::decoder\+\_\+opcode \textbf{ instruction\+Opcode}
\item 
const dl\+::\+Decoded\+Inst $\ast$ \textbf{ decoded\+Instruction}
\item 
\textbf{ Instruction} $\ast$ \textbf{ instruction}
\item 
\textbf{ uint32\+\_\+t} \textbf{ micro\+Op\+Type\+Offset}
\item 
\textbf{ uint32\+\_\+t} \textbf{ intra\+Instruction\+Dependencies}
\item 
\textbf{ uint32\+\_\+t} \textbf{ source\+Registers\+Length}
\item 
dl\+::\+Decoder\+::decoder\+\_\+reg \textbf{ source\+Registers} [\textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+SOURCE\+\_\+\+REGISTERS}]
\item 
\textbf{ uint32\+\_\+t} \textbf{ address\+Registers\+Length}
\item 
dl\+::\+Decoder\+::decoder\+\_\+reg \textbf{ address\+Registers} [\textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+ADDRESS\+\_\+\+REGISTERS}]
\item 
\textbf{ uint32\+\_\+t} \textbf{ destination\+Registers\+Length}
\item 
dl\+::\+Decoder\+::decoder\+\_\+reg \textbf{ destination\+Registers} [\textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+DESTINATION\+\_\+\+REGISTERS}]
\item 
\textbf{ Memory\+::\+Access} \textbf{ instruction\+Pointer}
\item 
bool \textbf{ interrupt}
\item 
bool \textbf{ serializing}
\item 
bool \textbf{ branch}
\item 
bool \textbf{ m\+\_\+membar}
\item 
bool \textbf{ is\+\_\+x87}
\item 
uint16\+\_\+t \textbf{ operand\+\_\+size}
\item 
uint16\+\_\+t \textbf{ memory\+Access\+Size}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
An instruction will be decoded in Micro\+Operations. There are 3 Micro\+Operation types\+: LOAD, EXECUTE AND STORE.

Example below\+: instruction with 2 loads, 1 execute and 2 stores. +-\/---+-\/---+ $\vert$ $\vert$ $\vert$ +-\/---+-\/---+-\/---+-\/---+-\/---+ $\vert$ L1 $\vert$ L2 $\vert$ E1 $\vert$ S1 $\vert$ S2 $\vert$ +-\/---+-\/---+-\/---+-\/---+-\/---+ $\vert$ $\vert$ $\vert$ +-\/---+-\/---+

E1 depend on L1 and L2\+: intra\+Instruction\+Dependencies = 2. S1 and S2 depend on E1\+: intra\+Instruction\+Dependencies = 1 (for both S1 and S2).

The type\+Offset for L1 = 0, L2 = 1, E1 = 0, S1 = 0, S2 = 1.

Getting the sequence\+Number of the Micro\+Operation for intra instruction dependencies\+: this-\/$>$sequence\+Number -\/ type\+Offset (= sequence\+Number of first micro\+Operation with the current type) -\/ intra\+Instruction\+Dependencies 

Definition at line \textbf{ 60} of file \textbf{ micro\+\_\+op.\+h}.



\doxysubsection{Member Enumeration Documentation}
\index{MicroOp@{MicroOp}!uop\_subtype\_t@{uop\_subtype\_t}}
\index{uop\_subtype\_t@{uop\_subtype\_t}!MicroOp@{MicroOp}}
\doxysubsubsection{uop\_subtype\_t}
{\footnotesize\ttfamily \label{structMicroOp_ad89eeea83b2adef50867036f6236b8d9} 
enum \textbf{ Micro\+Op\+::uop\+\_\+subtype\+\_\+t}}

\begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{UOP\_SUBTYPE\_FP\_ADDSUB@{UOP\_SUBTYPE\_FP\_ADDSUB}!MicroOp@{MicroOp}}\index{MicroOp@{MicroOp}!UOP\_SUBTYPE\_FP\_ADDSUB@{UOP\_SUBTYPE\_FP\_ADDSUB}}}\label{structMicroOp_ad89eeea83b2adef50867036f6236b8d9} 
UOP\+\_\+\+SUBTYPE\+\_\+\+FP\+\_\+\+ADDSUB&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{UOP\_SUBTYPE\_FP\_MULDIV@{UOP\_SUBTYPE\_FP\_MULDIV}!MicroOp@{MicroOp}}\index{MicroOp@{MicroOp}!UOP\_SUBTYPE\_FP\_MULDIV@{UOP\_SUBTYPE\_FP\_MULDIV}}}\label{structMicroOp_ad89eeea83b2adef50867036f6236b8d9} 
UOP\+\_\+\+SUBTYPE\+\_\+\+FP\+\_\+\+MULDIV&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{UOP\_SUBTYPE\_LOAD@{UOP\_SUBTYPE\_LOAD}!MicroOp@{MicroOp}}\index{MicroOp@{MicroOp}!UOP\_SUBTYPE\_LOAD@{UOP\_SUBTYPE\_LOAD}}}\label{structMicroOp_ad89eeea83b2adef50867036f6236b8d9} 
UOP\+\_\+\+SUBTYPE\+\_\+\+LOAD&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{UOP\_SUBTYPE\_STORE@{UOP\_SUBTYPE\_STORE}!MicroOp@{MicroOp}}\index{MicroOp@{MicroOp}!UOP\_SUBTYPE\_STORE@{UOP\_SUBTYPE\_STORE}}}\label{structMicroOp_ad89eeea83b2adef50867036f6236b8d9} 
UOP\+\_\+\+SUBTYPE\+\_\+\+STORE&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{UOP\_SUBTYPE\_GENERIC@{UOP\_SUBTYPE\_GENERIC}!MicroOp@{MicroOp}}\index{MicroOp@{MicroOp}!UOP\_SUBTYPE\_GENERIC@{UOP\_SUBTYPE\_GENERIC}}}\label{structMicroOp_ad89eeea83b2adef50867036f6236b8d9} 
UOP\+\_\+\+SUBTYPE\+\_\+\+GENERIC&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{UOP\_SUBTYPE\_BRANCH@{UOP\_SUBTYPE\_BRANCH}!MicroOp@{MicroOp}}\index{MicroOp@{MicroOp}!UOP\_SUBTYPE\_BRANCH@{UOP\_SUBTYPE\_BRANCH}}}\label{structMicroOp_ad89eeea83b2adef50867036f6236b8d9} 
UOP\+\_\+\+SUBTYPE\+\_\+\+BRANCH&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{UOP\_SUBTYPE\_SIZE@{UOP\_SUBTYPE\_SIZE}!MicroOp@{MicroOp}}\index{MicroOp@{MicroOp}!UOP\_SUBTYPE\_SIZE@{UOP\_SUBTYPE\_SIZE}}}\label{structMicroOp_ad89eeea83b2adef50867036f6236b8d9} 
UOP\+\_\+\+SUBTYPE\+\_\+\+SIZE&\\
\hline

\end{DoxyEnumFields}


Definition at line \textbf{ 68} of file \textbf{ micro\+\_\+op.\+h}.

\index{MicroOp@{MicroOp}!uop\_type\_t@{uop\_type\_t}}
\index{uop\_type\_t@{uop\_type\_t}!MicroOp@{MicroOp}}
\doxysubsubsection{uop\_type\_t}
{\footnotesize\ttfamily \label{structMicroOp_a828f968c88ca7733f34057b8eda87d56} 
enum \textbf{ Micro\+Op\+::uop\+\_\+type\+\_\+t}}

\begin{DoxyEnumFields}[2]{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{UOP\_INVALID@{UOP\_INVALID}!MicroOp@{MicroOp}}\index{MicroOp@{MicroOp}!UOP\_INVALID@{UOP\_INVALID}}}\label{structMicroOp_a828f968c88ca7733f34057b8eda87d56} 
UOP\+\_\+\+INVALID&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{UOP\_LOAD@{UOP\_LOAD}!MicroOp@{MicroOp}}\index{MicroOp@{MicroOp}!UOP\_LOAD@{UOP\_LOAD}}}\label{structMicroOp_a828f968c88ca7733f34057b8eda87d56} 
UOP\+\_\+\+LOAD&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{UOP\_EXECUTE@{UOP\_EXECUTE}!MicroOp@{MicroOp}}\index{MicroOp@{MicroOp}!UOP\_EXECUTE@{UOP\_EXECUTE}}}\label{structMicroOp_a828f968c88ca7733f34057b8eda87d56} 
UOP\+\_\+\+EXECUTE&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{UOP\_STORE@{UOP\_STORE}!MicroOp@{MicroOp}}\index{MicroOp@{MicroOp}!UOP\_STORE@{UOP\_STORE}}}\label{structMicroOp_a828f968c88ca7733f34057b8eda87d56} 
UOP\+\_\+\+STORE&\\
\hline

\end{DoxyEnumFields}


Definition at line \textbf{ 64} of file \textbf{ micro\+\_\+op.\+h}.



\doxysubsection{Constructor \& Destructor Documentation}
\index{MicroOp@{MicroOp}!MicroOp@{MicroOp}}
\index{MicroOp@{MicroOp}!MicroOp@{MicroOp}}
\doxysubsubsection{MicroOp()}
{\footnotesize\ttfamily \label{structMicroOp_a056486ad3c6acecf1aebba3615d4e791} 
Micro\+Op\+::\+Micro\+Op (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 23} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+ADDRESS\+\_\+\+REGISTERS}, \textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+DESTINATION\+\_\+\+REGISTERS}, \textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+SOURCE\+\_\+\+REGISTERS}, and \textbf{ uint32\+\_\+t}.



\doxysubsection{Member Function Documentation}
\index{MicroOp@{MicroOp}!addAddressRegister@{addAddressRegister}}
\index{addAddressRegister@{addAddressRegister}!MicroOp@{MicroOp}}
\doxysubsubsection{addAddressRegister()}
{\footnotesize\ttfamily \label{structMicroOp_ac0bc87cb2fccfc56f2e4b58d0c547c30} 
void Micro\+Op\+::add\+Address\+Register (\begin{DoxyParamCaption}\item[{dl\+::\+Decoder\+::decoder\+\_\+reg}]{register\+Id}{, }\item[{const String \&}]{register\+Name}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 262} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ address\+Registers}, \textbf{ address\+Registers\+Length}, \textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+ADDRESS\+\_\+\+REGISTERS}, and \textbf{ VERIFY\+\_\+\+MICROOP}.



Referenced by \textbf{ Instruction\+Decoder\+::add\+Addrs()}, and \textbf{ Instruction\+Decoder\+::add\+Addrs()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_ac0bc87cb2fccfc56f2e4b58d0c547c30_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!addDestinationRegister@{addDestinationRegister}}
\index{addDestinationRegister@{addDestinationRegister}!MicroOp@{MicroOp}}
\doxysubsubsection{addDestinationRegister()}
{\footnotesize\ttfamily \label{structMicroOp_a6353fc70df849286bb2d033806229861} 
void Micro\+Op\+::add\+Destination\+Register (\begin{DoxyParamCaption}\item[{dl\+::\+Decoder\+::decoder\+\_\+reg}]{register\+Id}{, }\item[{const String \&}]{register\+Name}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 292} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ destination\+Registers}, \textbf{ destination\+Registers\+Length}, \textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+DESTINATION\+\_\+\+REGISTERS}, and \textbf{ VERIFY\+\_\+\+MICROOP}.



Referenced by \textbf{ Instruction\+Decoder\+::add\+Dsts()}, and \textbf{ Instruction\+Decoder\+::add\+Dsts()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a6353fc70df849286bb2d033806229861_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!addSourceRegister@{addSourceRegister}}
\index{addSourceRegister@{addSourceRegister}!MicroOp@{MicroOp}}
\doxysubsubsection{addSourceRegister()}
{\footnotesize\ttfamily \label{structMicroOp_a4223a4f82d86290c777ba45acbaff422} 
void Micro\+Op\+::add\+Source\+Register (\begin{DoxyParamCaption}\item[{dl\+::\+Decoder\+::decoder\+\_\+reg}]{register\+Id}{, }\item[{const String \&}]{register\+Name}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 232} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+SOURCE\+\_\+\+REGISTERS}, \textbf{ source\+Registers}, \textbf{ source\+Registers\+Length}, and \textbf{ VERIFY\+\_\+\+MICROOP}.



Referenced by \textbf{ Instruction\+Decoder\+::add\+Srcs()}, and \textbf{ Instruction\+Decoder\+::add\+Srcs()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a4223a4f82d86290c777ba45acbaff422_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!getAddressRegister@{getAddressRegister}}
\index{getAddressRegister@{getAddressRegister}!MicroOp@{MicroOp}}
\doxysubsubsection{getAddressRegister()}
{\footnotesize\ttfamily \label{structMicroOp_ad7aefb83dac3e427298f12cc7d9bc0b8} 
dl\+::\+Decoder\+::decoder\+\_\+reg Micro\+Op\+::get\+Address\+Register (\begin{DoxyParamCaption}\item[{\textbf{ uint32\+\_\+t}}]{index}{}\end{DoxyParamCaption}) const}



Definition at line \textbf{ 248} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ address\+Registers}, \textbf{ address\+Registers\+Length}, and \textbf{ VERIFY\+\_\+\+MICROOP}.



Referenced by \textbf{ Rob\+Smt\+Timer\+::set\+Store\+Address\+Producers()}, and \textbf{ Rob\+Timer\+::simulate()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_ad7aefb83dac3e427298f12cc7d9bc0b8_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!getAddressRegistersLength@{getAddressRegistersLength}}
\index{getAddressRegistersLength@{getAddressRegistersLength}!MicroOp@{MicroOp}}
\doxysubsubsection{getAddressRegistersLength()}
{\footnotesize\ttfamily \label{structMicroOp_abb95e283ec98f928fc1d1de7b177fca2} 
\textbf{ uint32\+\_\+t} Micro\+Op\+::get\+Address\+Registers\+Length (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Definition at line \textbf{ 243} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ address\+Registers\+Length}, and \textbf{ VERIFY\+\_\+\+MICROOP}.

\index{MicroOp@{MicroOp}!getDecodedInstruction@{getDecodedInstruction}}
\index{getDecodedInstruction@{getDecodedInstruction}!MicroOp@{MicroOp}}
\doxysubsubsection{getDecodedInstruction()}
{\footnotesize\ttfamily \label{structMicroOp_ae49dd1116421e6a62d2dd8adec015111} 
const dl\+::\+Decoded\+Inst $\ast$ Micro\+Op\+::get\+Decoded\+Instruction (\begin{DoxyParamCaption}\item[{void}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 159} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ decoded\+Instruction}.



Referenced by \textbf{ get\+Subtype\+\_\+\+Exec()}, and \textbf{ is\+Fp\+Load\+Store()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_ae49dd1116421e6a62d2dd8adec015111_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!getDestinationRegister@{getDestinationRegister}}
\index{getDestinationRegister@{getDestinationRegister}!MicroOp@{MicroOp}}
\doxysubsubsection{getDestinationRegister()}
{\footnotesize\ttfamily \label{structMicroOp_a716ce39f5f87f50fca198449796860a1} 
dl\+::\+Decoder\+::decoder\+\_\+reg Micro\+Op\+::get\+Destination\+Register (\begin{DoxyParamCaption}\item[{\textbf{ uint32\+\_\+t}}]{index}{}\end{DoxyParamCaption}) const}



Definition at line \textbf{ 278} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ destination\+Registers}, \textbf{ destination\+Registers\+Length}, and \textbf{ VERIFY\+\_\+\+MICROOP}.



Referenced by \textbf{ Register\+Dependencies\+::set\+Dependencies()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a716ce39f5f87f50fca198449796860a1_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!getDestinationRegistersLength@{getDestinationRegistersLength}}
\index{getDestinationRegistersLength@{getDestinationRegistersLength}!MicroOp@{MicroOp}}
\doxysubsubsection{getDestinationRegistersLength()}
{\footnotesize\ttfamily \label{structMicroOp_a16c13da19e779c209cee7f6a520dd1b4} 
\textbf{ uint32\+\_\+t} Micro\+Op\+::get\+Destination\+Registers\+Length (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Definition at line \textbf{ 273} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ destination\+Registers\+Length}, and \textbf{ VERIFY\+\_\+\+MICROOP}.



Referenced by \textbf{ to\+String()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a16c13da19e779c209cee7f6a520dd1b4_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!getInstruction@{getInstruction}}
\index{getInstruction@{getInstruction}!MicroOp@{MicroOp}}
\doxysubsubsection{getInstruction()}
{\footnotesize\ttfamily \label{structMicroOp_a4cb7503ec455a1135068638229d58bbc} 
\textbf{ Instruction} $\ast$ Micro\+Op\+::get\+Instruction (\begin{DoxyParamCaption}\item[{void}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 156} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ instruction}.



Referenced by \textbf{ Rob\+Smt\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Timer\+::issue\+Instruction()}, \textbf{ Interval\+Timer\+::issue\+Mem\+Op()}, \textbf{ Rob\+Smt\+Timer\+::print\+Rob()}, \textbf{ Rob\+Timer\+::print\+Rob()}, \textbf{ to\+Short\+String()}, \textbf{ Loop\+Profiler\+::trace\+Instruction()}, and \textbf{ Loop\+Tracer\+::trace\+Instruction()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a4cb7503ec455a1135068638229d58bbc_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!getInstructionOpcode@{getInstructionOpcode}}
\index{getInstructionOpcode@{getInstructionOpcode}!MicroOp@{MicroOp}}
\doxysubsubsection{getInstructionOpcode()}
{\footnotesize\ttfamily \label{structMicroOp_a3f3607a415ab6257813109cf7ea1fce4} 
dl\+::\+Decoder\+::decoder\+\_\+opcode Micro\+Op\+::get\+Instruction\+Opcode (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 161} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ instruction\+Opcode}.



Referenced by \textbf{ Dynamic\+Micro\+Op\+Boom\+V1\+::get\+Alu()}, \textbf{ Dynamic\+Micro\+Op\+Nehalem\+::get\+Alu()}, \textbf{ Core\+Model\+Boom\+V1\+::get\+Alu\+Latency()}, \textbf{ Core\+Model\+Nehalem\+::get\+Alu\+Latency()}, \textbf{ Core\+Model\+Boom\+V1\+::get\+Instruction\+Latency()}, \textbf{ Core\+Model\+Nehalem\+::get\+Instruction\+Latency()}, \textbf{ Dynamic\+Micro\+Op\+Boom\+V1\+::get\+Port()}, \textbf{ Dynamic\+Micro\+Op\+Nehalem\+::get\+Port()}, \textbf{ get\+Subtype\+\_\+\+Exec()}, \textbf{ is\+Fp\+Load\+Store()}, and \textbf{ Instruction\+Tracer\+Print\+::trace\+Instruction()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a3f3607a415ab6257813109cf7ea1fce4_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!getInstructionPointer@{getInstructionPointer}}
\index{getInstructionPointer@{getInstructionPointer}!MicroOp@{MicroOp}}
\doxysubsubsection{getInstructionPointer()}
{\footnotesize\ttfamily \label{structMicroOp_a185efa91a135108d3e5124c6be317317} 
const \textbf{ Memory\+::\+Access} \& Micro\+Op\+::get\+Instruction\+Pointer (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 189} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ instruction\+Pointer}.

\index{MicroOp@{MicroOp}!getMemoryAccessSize@{getMemoryAccessSize}}
\index{getMemoryAccessSize@{getMemoryAccessSize}!MicroOp@{MicroOp}}
\doxysubsubsection{getMemoryAccessSize()}
{\footnotesize\ttfamily \label{structMicroOp_a4255fe7372e6296959921db77c2bba11} 
uint16\+\_\+t Micro\+Op\+::get\+Memory\+Access\+Size (\begin{DoxyParamCaption}\item[{void}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 153} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ memory\+Access\+Size}.



Referenced by \textbf{ Rob\+Smt\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Timer\+::issue\+Instruction()}, and \textbf{ Interval\+Timer\+::issue\+Mem\+Op()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a4255fe7372e6296959921db77c2bba11_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!getOperandSize@{getOperandSize}}
\index{getOperandSize@{getOperandSize}!MicroOp@{MicroOp}}
\doxysubsubsection{getOperandSize()}
{\footnotesize\ttfamily \label{structMicroOp_aeb51ed40d7b7c9d3069c535777d3f7c5} 
uint16\+\_\+t Micro\+Op\+::get\+Operand\+Size (\begin{DoxyParamCaption}\item[{void}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 152} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ operand\+\_\+size}.



Referenced by \textbf{ Core\+Model\+Nehalem\+::get\+Alu\+Latency()}, and \textbf{ Dynamic\+Micro\+Op\+Nehalem\+::get\+Port()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_aeb51ed40d7b7c9d3069c535777d3f7c5_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!getSourceRegister@{getSourceRegister}}
\index{getSourceRegister@{getSourceRegister}!MicroOp@{MicroOp}}
\doxysubsubsection{getSourceRegister()}
{\footnotesize\ttfamily \label{structMicroOp_a7ed0dc5a2627970d7ab0c05604d2b74d} 
dl\+::\+Decoder\+::decoder\+\_\+reg Micro\+Op\+::get\+Source\+Register (\begin{DoxyParamCaption}\item[{\textbf{ uint32\+\_\+t}}]{index}{}\end{DoxyParamCaption}) const}



Definition at line \textbf{ 218} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ source\+Registers}, \textbf{ source\+Registers\+Length}, and \textbf{ VERIFY\+\_\+\+MICROOP}.



Referenced by \textbf{ Register\+Dependencies\+::set\+Dependencies()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a7ed0dc5a2627970d7ab0c05604d2b74d_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!getSourceRegistersLength@{getSourceRegistersLength}}
\index{getSourceRegistersLength@{getSourceRegistersLength}!MicroOp@{MicroOp}}
\doxysubsubsection{getSourceRegistersLength()}
{\footnotesize\ttfamily \label{structMicroOp_a291383ad070f62328a68b9a85a887075} 
\textbf{ uint32\+\_\+t} Micro\+Op\+::get\+Source\+Registers\+Length (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Definition at line \textbf{ 213} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ source\+Registers\+Length}, and \textbf{ VERIFY\+\_\+\+MICROOP}.



Referenced by \textbf{ to\+String()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a291383ad070f62328a68b9a85a887075_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!getSubtype@{getSubtype}}
\index{getSubtype@{getSubtype}!MicroOp@{MicroOp}}
\doxysubsubsection{getSubtype()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{structMicroOp_a3788750d8526860b9c03bc318cc80d57} 
\textbf{ Micro\+Op\+::uop\+\_\+subtype\+\_\+t} Micro\+Op\+::get\+Subtype (\begin{DoxyParamCaption}\item[{const \textbf{ Micro\+Op} \&}]{uop}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 144} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ get\+Subtype\+\_\+\+Exec()}, \textbf{ is\+Branch()}, \textbf{ is\+Execute()}, \textbf{ is\+Load()}, \textbf{ is\+Store()}, \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+BRANCH}, \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+GENERIC}, \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+LOAD}, and \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+STORE}.



Referenced by \textbf{ Dynamic\+Micro\+Op\+Boom\+V1\+::get\+Bypass\+Type()}, \textbf{ Dynamic\+Micro\+Op\+Nehalem\+::get\+Bypass\+Type()}, and \textbf{ get\+Cp\+Contr\+Type()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a3788750d8526860b9c03bc318cc80d57_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a3788750d8526860b9c03bc318cc80d57_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!getSubtype@{getSubtype}}
\index{getSubtype@{getSubtype}!MicroOp@{MicroOp}}
\doxysubsubsection{getSubtype()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{structMicroOp_a7059e39cf8040e25f79f6a9d00271c82} 
\textbf{ uop\+\_\+subtype\+\_\+t} Micro\+Op\+::get\+Subtype (\begin{DoxyParamCaption}\item[{void}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 146} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ uop\+\_\+subtype}.



Referenced by \textbf{ set\+Types()}, and \textbf{ verify()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a7059e39cf8040e25f79f6a9d00271c82_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!getSubtype\_Exec@{getSubtype\_Exec}}
\index{getSubtype\_Exec@{getSubtype\_Exec}!MicroOp@{MicroOp}}
\doxysubsubsection{getSubtype\_Exec()}
{\footnotesize\ttfamily \label{structMicroOp_ad30c260ba8b14f370c745a9211cca9e3} 
\textbf{ Micro\+Op\+::uop\+\_\+subtype\+\_\+t} Micro\+Op\+::get\+Subtype\+\_\+\+Exec (\begin{DoxyParamCaption}\item[{const \textbf{ Micro\+Op} \&}]{uop}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 123} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ get\+Decoded\+Instruction()}, \textbf{ get\+Instruction\+Opcode()}, \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+BRANCH}, \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+FP\+\_\+\+ADDSUB}, \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+FP\+\_\+\+MULDIV}, and \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+GENERIC}.



Referenced by \textbf{ get\+Subtype()}, and \textbf{ is\+Fp\+Load\+Store()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_ad30c260ba8b14f370c745a9211cca9e3_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_ad30c260ba8b14f370c745a9211cca9e3_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!getSubtypeString@{getSubtypeString}}
\index{getSubtypeString@{getSubtypeString}!MicroOp@{MicroOp}}
\doxysubsubsection{getSubtypeString()}
{\footnotesize\ttfamily \label{structMicroOp_a5bf9b019131ef434d698cec3c994c795} 
String Micro\+Op\+::get\+Subtype\+String (\begin{DoxyParamCaption}\item[{\textbf{ uop\+\_\+subtype\+\_\+t}}]{uop\+\_\+subtype}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Definition at line \textbf{ 160} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ LOG\+\_\+\+ASSERT\+\_\+\+ERROR}, \textbf{ uop\+\_\+subtype}, \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+BRANCH}, \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+FP\+\_\+\+ADDSUB}, \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+FP\+\_\+\+MULDIV}, \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+GENERIC}, \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+LOAD}, and \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+STORE}.



Referenced by \textbf{ Rob\+Smt\+Timer\+::initialize\+Thread()}, \textbf{ Interval\+Timer\+::\+Interval\+Timer()}, and \textbf{ Rob\+Timer\+::\+Rob\+Timer()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a5bf9b019131ef434d698cec3c994c795_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!getType@{getType}}
\index{getType@{getType}!MicroOp@{MicroOp}}
\doxysubsubsection{getType()}
{\footnotesize\ttfamily \label{structMicroOp_a4e1fa94f816f512ce7f749a3123aaf9b} 
\textbf{ uop\+\_\+type\+\_\+t} Micro\+Op\+::get\+Type (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 215} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ uop\+\_\+type}.



Referenced by \textbf{ Micro\+Op\+Performance\+Model\+::do\+Squashing()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a4e1fa94f816f512ce7f749a3123aaf9b_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!isBranch@{isBranch}}
\index{isBranch@{isBranch}!MicroOp@{MicroOp}}
\doxysubsubsection{isBranch()}
{\footnotesize\ttfamily \label{structMicroOp_abba6bddc10e03c04917212c4aa74464a} 
bool Micro\+Op\+::is\+Branch (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 192} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ branch}.



Referenced by \textbf{ Interval\+Timer\+::block\+Window()}, \textbf{ Interval\+Timer\+::dispatch\+Instruction()}, \textbf{ Rob\+Timer\+::do\+Dispatch()}, \textbf{ Dynamic\+Micro\+Op\+::get\+Branch\+Target()}, \textbf{ get\+Subtype()}, \textbf{ Dynamic\+Micro\+Op\+::is\+Branch\+Mispredicted()}, \textbf{ Dynamic\+Micro\+Op\+::is\+Branch\+Taken()}, \textbf{ Rob\+Smt\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Timer\+::issue\+Instruction()}, \textbf{ make\+Execute()}, \textbf{ Dynamic\+Micro\+Op\+::set\+Branch\+Taken()}, \textbf{ to\+String()}, and \textbf{ Rob\+Smt\+Timer\+::try\+Dispatch()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_abba6bddc10e03c04917212c4aa74464a_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!isCacheFlush@{isCacheFlush}}
\index{isCacheFlush@{isCacheFlush}!MicroOp@{MicroOp}}
\doxysubsubsection{isCacheFlush()}
{\footnotesize\ttfamily \label{structMicroOp_a4c65bd52a8c64bd63775acd65abda6b3} 
bool Micro\+Op\+::is\+Cache\+Flush (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 202} of file \textbf{ micro\+\_\+op.\+h}.

\index{MicroOp@{MicroOp}!isDiv@{isDiv}}
\index{isDiv@{isDiv}!MicroOp@{MicroOp}}
\doxysubsubsection{isDiv()}
{\footnotesize\ttfamily \label{structMicroOp_aea55b5514e7fd44cca2a6eeea836920e} 
bool Micro\+Op\+::is\+Div (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 203} of file \textbf{ micro\+\_\+op.\+h}.

\index{MicroOp@{MicroOp}!isExecute@{isExecute}}
\index{isExecute@{isExecute}!MicroOp@{MicroOp}}
\doxysubsubsection{isExecute()}
{\footnotesize\ttfamily \label{structMicroOp_a96acd9cc8dd75e0c8a42c766d9507e28} 
bool Micro\+Op\+::is\+Execute (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 213} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ UOP\+\_\+\+EXECUTE}, and \textbf{ uop\+\_\+type}.



Referenced by \textbf{ Interval\+Timer\+::dispatch\+Instruction()}, and \textbf{ get\+Subtype()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a96acd9cc8dd75e0c8a42c766d9507e28_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!isFirst@{isFirst}}
\index{isFirst@{isFirst}!MicroOp@{MicroOp}}
\doxysubsubsection{isFirst()}
{\footnotesize\ttfamily \label{structMicroOp_a4855b06c41269e0102f862adc93e6432} 
bool Micro\+Op\+::is\+First (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 164} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ first}.



Referenced by \textbf{ Dynamic\+Micro\+Op\+::\+Dynamic\+Micro\+Op()}, \textbf{ to\+String()}, \textbf{ Instruction\+Tracer\+FPStats\+::trace\+Instruction()}, and \textbf{ Loop\+Profiler\+::trace\+Instruction()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a4855b06c41269e0102f862adc93e6432_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!isFpLoadStore@{isFpLoadStore}}
\index{isFpLoadStore@{isFpLoadStore}!MicroOp@{MicroOp}}
\doxysubsubsection{isFpLoadStore()}
{\footnotesize\ttfamily \label{structMicroOp_a873a0bbae5f02ac19a61216e9eada904} 
bool Micro\+Op\+::is\+Fp\+Load\+Store (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Definition at line \textbf{ 181} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ get\+Decoded\+Instruction()}, \textbf{ get\+Instruction\+Opcode()}, \textbf{ get\+Subtype\+\_\+\+Exec()}, \textbf{ is\+Load()}, \textbf{ is\+Store()}, \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+FP\+\_\+\+ADDSUB}, and \textbf{ UOP\+\_\+\+SUBTYPE\+\_\+\+FP\+\_\+\+MULDIV}.



Referenced by \textbf{ Dynamic\+Micro\+Op\+Boom\+V1\+::get\+Bypass\+Type()}, and \textbf{ Dynamic\+Micro\+Op\+Nehalem\+::get\+Bypass\+Type()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a873a0bbae5f02ac19a61216e9eada904_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a873a0bbae5f02ac19a61216e9eada904_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!isInterrupt@{isInterrupt}}
\index{isInterrupt@{isInterrupt}!MicroOp@{MicroOp}}
\doxysubsubsection{isInterrupt()}
{\footnotesize\ttfamily \label{structMicroOp_aaea7f86dd0a0ef87d2dfd43cce6ab92a} 
bool Micro\+Op\+::is\+Interrupt (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 194} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ interrupt}.



Referenced by \textbf{ Interval\+Timer\+::dispatch\+Instruction()}, and \textbf{ to\+String()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_aaea7f86dd0a0ef87d2dfd43cce6ab92a_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!isLast@{isLast}}
\index{isLast@{isLast}!MicroOp@{MicroOp}}
\doxysubsubsection{isLast()}
{\footnotesize\ttfamily \label{structMicroOp_a44d42109b0fbe70c955d2b80861ca258} 
bool Micro\+Op\+::is\+Last (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 167} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ last}.



Referenced by \textbf{ Dynamic\+Micro\+Op\+::\+Dynamic\+Micro\+Op()}, \textbf{ to\+String()}, and \textbf{ Loop\+Tracer\+::trace\+Instruction()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a44d42109b0fbe70c955d2b80861ca258_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!isLoad@{isLoad}}
\index{isLoad@{isLoad}!MicroOp@{MicroOp}}
\doxysubsubsection{isLoad()}
{\footnotesize\ttfamily \label{structMicroOp_aaaa9d4e0497cd79bab66e318a19fdb88} 
bool Micro\+Op\+::is\+Load (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 206} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ UOP\+\_\+\+LOAD}.



Referenced by \textbf{ Interval\+Timer\+::block\+Window()}, \textbf{ Rob\+Smt\+Timer\+::count\+Outstanding\+Memop()}, \textbf{ Rob\+Timer\+::count\+Outstanding\+Memop()}, \textbf{ Interval\+Timer\+::dispatch\+Instruction()}, \textbf{ Rob\+Timer\+::do\+Issue()}, \textbf{ Rob\+Smt\+Timer\+::find\+Cpi\+Component()}, \textbf{ Rob\+Timer\+::find\+Cpi\+Component()}, \textbf{ get\+Subtype()}, \textbf{ is\+Fp\+Load\+Store()}, \textbf{ Rob\+Smt\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Timer\+::issue\+Instruction()}, \textbf{ Interval\+Timer\+::issue\+Mem\+Op()}, \textbf{ Rob\+Smt\+Timer\+::print\+Rob()}, \textbf{ Rob\+Timer\+::print\+Rob()}, \textbf{ Memory\+Dependencies\+::set\+Dependencies()}, \textbf{ Rob\+Smt\+Timer\+::set\+Dependencies()}, \textbf{ Rob\+Timer\+::simulate()}, and \textbf{ Rob\+Smt\+Timer\+::try\+Issue()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_aaaa9d4e0497cd79bab66e318a19fdb88_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!isMemBarrier@{isMemBarrier}}
\index{isMemBarrier@{isMemBarrier}!MicroOp@{MicroOp}}
\doxysubsubsection{isMemBarrier()}
{\footnotesize\ttfamily \label{structMicroOp_a03aa904a878a0c4f536fb2aee407752e} 
bool Micro\+Op\+::is\+Mem\+Barrier (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 200} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ m\+\_\+membar}.



Referenced by \textbf{ Interval\+Timer\+::block\+Window()}, \textbf{ Interval\+Timer\+::dispatch\+Instruction()}, \textbf{ Rob\+Timer\+::do\+Issue()}, \textbf{ Rob\+Smt\+Timer\+::find\+Cpi\+Component()}, \textbf{ Rob\+Timer\+::find\+Cpi\+Component()}, \textbf{ Memory\+Dependencies\+::set\+Dependencies()}, and \textbf{ Rob\+Smt\+Timer\+::try\+Issue()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a03aa904a878a0c4f536fb2aee407752e_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!isPause@{isPause}}
\index{isPause@{isPause}!MicroOp@{MicroOp}}
\doxysubsubsection{isPause()}
{\footnotesize\ttfamily \label{structMicroOp_ae545b2da8a7475a6a0ac07fe80d5f6b3} 
bool Micro\+Op\+::is\+Pause (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 204} of file \textbf{ micro\+\_\+op.\+h}.

\index{MicroOp@{MicroOp}!isSerializing@{isSerializing}}
\index{isSerializing@{isSerializing}!MicroOp@{MicroOp}}
\doxysubsubsection{isSerializing()}
{\footnotesize\ttfamily \label{structMicroOp_a4c0824bd00571084a63250256d961f1e} 
bool Micro\+Op\+::is\+Serializing (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 197} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ serializing}.



Referenced by \textbf{ Interval\+Timer\+::block\+Window()}, \textbf{ Interval\+Timer\+::dispatch\+Instruction()}, \textbf{ Rob\+Timer\+::do\+Issue()}, \textbf{ Rob\+Smt\+Timer\+::find\+Cpi\+Component()}, \textbf{ Rob\+Timer\+::find\+Cpi\+Component()}, \textbf{ to\+String()}, and \textbf{ Rob\+Smt\+Timer\+::try\+Issue()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a4c0824bd00571084a63250256d961f1e_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!isStore@{isStore}}
\index{isStore@{isStore}!MicroOp@{MicroOp}}
\doxysubsubsection{isStore()}
{\footnotesize\ttfamily \label{structMicroOp_a6fb2cf52d0355b55fc40f8c41d0ff41a} 
bool Micro\+Op\+::is\+Store (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 207} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ UOP\+\_\+\+STORE}.



Referenced by \textbf{ Interval\+Timer\+::dispatch\+Instruction()}, \textbf{ Rob\+Timer\+::do\+Issue()}, \textbf{ Rob\+Smt\+Timer\+::find\+Cpi\+Component()}, \textbf{ Rob\+Timer\+::find\+Cpi\+Component()}, \textbf{ get\+Subtype()}, \textbf{ is\+Fp\+Load\+Store()}, \textbf{ Rob\+Smt\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Timer\+::issue\+Instruction()}, \textbf{ Interval\+Timer\+::issue\+Mem\+Op()}, \textbf{ Rob\+Smt\+Timer\+::print\+Rob()}, \textbf{ Rob\+Timer\+::print\+Rob()}, \textbf{ Memory\+Dependencies\+::set\+Dependencies()}, \textbf{ Rob\+Smt\+Timer\+::set\+Dependencies()}, \textbf{ Rob\+Timer\+::simulate()}, and \textbf{ Rob\+Smt\+Timer\+::try\+Issue()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a6fb2cf52d0355b55fc40f8c41d0ff41a_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!isX87@{isX87}}
\index{isX87@{isX87}!MicroOp@{MicroOp}}
\doxysubsubsection{isX87()}
{\footnotesize\ttfamily \label{structMicroOp_a370700900970b3c6e7a4d97245b156a1} 
bool Micro\+Op\+::is\+X87 (\begin{DoxyParamCaption}\item[{void}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 150} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ is\+\_\+x87}.

\index{MicroOp@{MicroOp}!makeDynamic@{makeDynamic}}
\index{makeDynamic@{makeDynamic}!MicroOp@{MicroOp}}
\doxysubsubsection{makeDynamic()}
{\footnotesize\ttfamily \label{structMicroOp_a20ec6571cd60d96c30e45dff2f2a9f86} 
void Micro\+Op\+::make\+Dynamic (\begin{DoxyParamCaption}\item[{const String \&}]{instruction\+Opcode\+Name}{, }\item[{\textbf{ uint32\+\_\+t}}]{exec\+Latency}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 110} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ branch}, \textbf{ instruction\+Opcode}, \textbf{ intra\+Instruction\+Dependencies}, \textbf{ micro\+Op\+Type\+Offset}, \textbf{ set\+Types()}, \textbf{ UOP\+\_\+\+EXECUTE}, and \textbf{ uop\+\_\+type}.



Referenced by \textbf{ Micro\+Op\+Performance\+Model\+::\+Micro\+Op\+Performance\+Model()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a20ec6571cd60d96c30e45dff2f2a9f86_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=338pt]{structMicroOp_a20ec6571cd60d96c30e45dff2f2a9f86_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!makeExecute@{makeExecute}}
\index{makeExecute@{makeExecute}!MicroOp@{MicroOp}}
\doxysubsubsection{makeExecute()}
{\footnotesize\ttfamily \label{structMicroOp_a8c2446e662936b55ce20687514789913} 
void Micro\+Op\+::make\+Execute (\begin{DoxyParamCaption}\item[{\textbf{ uint32\+\_\+t}}]{offset}{, }\item[{\textbf{ uint32\+\_\+t}}]{num\+\_\+loads}{, }\item[{dl\+::\+Decoder\+::decoder\+\_\+opcode}]{instruction\+Opcode}{, }\item[{const String \&}]{instruction\+Opcode\+Name}{, }\item[{bool}]{is\+Branch}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 86} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ branch}, \textbf{ instruction\+Opcode}, \textbf{ intra\+Instruction\+Dependencies}, \textbf{ is\+Branch()}, \textbf{ micro\+Op\+Type\+Offset}, \textbf{ set\+Types()}, \textbf{ UOP\+\_\+\+EXECUTE}, and \textbf{ uop\+\_\+type}.



Referenced by \textbf{ Instruction\+Decoder\+::decode()}, and \textbf{ Instruction\+Decoder\+::decode()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a8c2446e662936b55ce20687514789913_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a8c2446e662936b55ce20687514789913_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!makeLoad@{makeLoad}}
\index{makeLoad@{makeLoad}!MicroOp@{MicroOp}}
\doxysubsubsection{makeLoad()}
{\footnotesize\ttfamily \label{structMicroOp_ac9eb79d1dda26c6bd3b0c52eefc82ed7} 
void Micro\+Op\+::make\+Load (\begin{DoxyParamCaption}\item[{\textbf{ uint32\+\_\+t}}]{offset}{, }\item[{dl\+::\+Decoder\+::decoder\+\_\+opcode}]{instruction\+Opcode}{, }\item[{const String \&}]{instruction\+Opcode\+Name}{, }\item[{uint16\+\_\+t}]{mem\+\_\+size}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 74} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ instruction\+Opcode}, \textbf{ intra\+Instruction\+Dependencies}, \textbf{ memory\+Access\+Size}, \textbf{ micro\+Op\+Type\+Offset}, \textbf{ set\+Types()}, \textbf{ UOP\+\_\+\+LOAD}, and \textbf{ uop\+\_\+type}.



Referenced by \textbf{ Instruction\+Decoder\+::decode()}, \textbf{ Instruction\+Decoder\+::decode()}, and \textbf{ Micro\+Op\+Performance\+Model\+::\+Micro\+Op\+Performance\+Model()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_ac9eb79d1dda26c6bd3b0c52eefc82ed7_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_ac9eb79d1dda26c6bd3b0c52eefc82ed7_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!makeStore@{makeStore}}
\index{makeStore@{makeStore}!MicroOp@{MicroOp}}
\doxysubsubsection{makeStore()}
{\footnotesize\ttfamily \label{structMicroOp_a40caf6e2ace0c90e4abd9e25005ee77c} 
void Micro\+Op\+::make\+Store (\begin{DoxyParamCaption}\item[{\textbf{ uint32\+\_\+t}}]{offset}{, }\item[{\textbf{ uint32\+\_\+t}}]{num\+\_\+execute}{, }\item[{dl\+::\+Decoder\+::decoder\+\_\+opcode}]{instruction\+Opcode}{, }\item[{const String \&}]{instruction\+Opcode\+Name}{, }\item[{uint16\+\_\+t}]{mem\+\_\+size}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 98} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ instruction\+Opcode}, \textbf{ intra\+Instruction\+Dependencies}, \textbf{ memory\+Access\+Size}, \textbf{ micro\+Op\+Type\+Offset}, \textbf{ set\+Types()}, \textbf{ UOP\+\_\+\+STORE}, and \textbf{ uop\+\_\+type}.



Referenced by \textbf{ Instruction\+Decoder\+::decode()}, and \textbf{ Instruction\+Decoder\+::decode()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a40caf6e2ace0c90e4abd9e25005ee77c_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a40caf6e2ace0c90e4abd9e25005ee77c_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!setDebugInfo@{setDebugInfo}}
\index{setDebugInfo@{setDebugInfo}!MicroOp@{MicroOp}}
\doxysubsubsection{setDebugInfo()}
{\footnotesize\ttfamily \label{structMicroOp_a98ecd6c55b74bee0e166b8866b660468} 
void Micro\+Op\+::set\+Debug\+Info (\begin{DoxyParamCaption}\item[{String}]{debug\+Info}{}\end{DoxyParamCaption})}

\index{MicroOp@{MicroOp}!setDecodedInstruction@{setDecodedInstruction}}
\index{setDecodedInstruction@{setDecodedInstruction}!MicroOp@{MicroOp}}
\doxysubsubsection{setDecodedInstruction()}
{\footnotesize\ttfamily \label{structMicroOp_ada69f748d3e5c536f14adb9608eaaf7f} 
void Micro\+Op\+::set\+Decoded\+Instruction (\begin{DoxyParamCaption}\item[{const dl\+::\+Decoded\+Inst $\ast$}]{instr}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 158} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ decoded\+Instruction}.



Referenced by \textbf{ Instruction\+Decoder\+::decode()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=333pt]{structMicroOp_ada69f748d3e5c536f14adb9608eaaf7f_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!setFirst@{setFirst}}
\index{setFirst@{setFirst}!MicroOp@{MicroOp}}
\doxysubsubsection{setFirst()}
{\footnotesize\ttfamily \label{structMicroOp_abc87e72396709dd0e4611061c465e973} 
void Micro\+Op\+::set\+First (\begin{DoxyParamCaption}\item[{bool}]{first}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 163} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ first}.



Referenced by \textbf{ Instruction\+Decoder\+::decode()}, \textbf{ Instruction\+Decoder\+::decode()}, and \textbf{ Micro\+Op\+Performance\+Model\+::\+Micro\+Op\+Performance\+Model()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_abc87e72396709dd0e4611061c465e973_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!setInstruction@{setInstruction}}
\index{setInstruction@{setInstruction}!MicroOp@{MicroOp}}
\doxysubsubsection{setInstruction()}
{\footnotesize\ttfamily \label{structMicroOp_a986db86753717690176b90556039287a} 
void Micro\+Op\+::set\+Instruction (\begin{DoxyParamCaption}\item[{\textbf{ Instruction} $\ast$}]{instr}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 155} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ instruction}.



Referenced by \textbf{ Instruction\+Decoder\+::decode()}, and \textbf{ Instruction\+Decoder\+::decode()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a986db86753717690176b90556039287a_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!setInstructionPointer@{setInstructionPointer}}
\index{setInstructionPointer@{setInstructionPointer}!MicroOp@{MicroOp}}
\doxysubsubsection{setInstructionPointer()}
{\footnotesize\ttfamily \label{structMicroOp_a933d562c4e014d7f9166be6ae3798d24} 
void Micro\+Op\+::set\+Instruction\+Pointer (\begin{DoxyParamCaption}\item[{const \textbf{ Memory\+::\+Access} \&}]{ip}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 190} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ Instruction\+Decoder\+::decode()}, and \textbf{ Instruction\+Decoder\+::decode()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a933d562c4e014d7f9166be6ae3798d24_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!setInterrupt@{setInterrupt}}
\index{setInterrupt@{setInterrupt}!MicroOp@{MicroOp}}
\doxysubsubsection{setInterrupt()}
{\footnotesize\ttfamily \label{structMicroOp_acee9c0d1aad25226438a4936f4a2dbcd} 
void Micro\+Op\+::set\+Interrupt (\begin{DoxyParamCaption}\item[{bool}]{interrupt}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 195} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ interrupt}.



Referenced by \textbf{ Instruction\+Decoder\+::decode()}, and \textbf{ Instruction\+Decoder\+::decode()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_acee9c0d1aad25226438a4936f4a2dbcd_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!setIsX87@{setIsX87}}
\index{setIsX87@{setIsX87}!MicroOp@{MicroOp}}
\doxysubsubsection{setIsX87()}
{\footnotesize\ttfamily \label{structMicroOp_a5f8bbb3847fb8399e56d2763c3435384} 
void Micro\+Op\+::set\+Is\+X87 (\begin{DoxyParamCaption}\item[{bool}]{\+\_\+is\+\_\+x87}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 149} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ is\+\_\+x87}.



Referenced by \textbf{ Instruction\+Decoder\+::decode()}, and \textbf{ Instruction\+Decoder\+::decode()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a5f8bbb3847fb8399e56d2763c3435384_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!setLast@{setLast}}
\index{setLast@{setLast}!MicroOp@{MicroOp}}
\doxysubsubsection{setLast()}
{\footnotesize\ttfamily \label{structMicroOp_a762b0bb142b66919b65bbe5054ffd052} 
void Micro\+Op\+::set\+Last (\begin{DoxyParamCaption}\item[{bool}]{last}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 166} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ last}.



Referenced by \textbf{ Instruction\+Decoder\+::decode()}, \textbf{ Instruction\+Decoder\+::decode()}, and \textbf{ Micro\+Op\+Performance\+Model\+::\+Micro\+Op\+Performance\+Model()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a762b0bb142b66919b65bbe5054ffd052_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!setMemBarrier@{setMemBarrier}}
\index{setMemBarrier@{setMemBarrier}!MicroOp@{MicroOp}}
\doxysubsubsection{setMemBarrier()}
{\footnotesize\ttfamily \label{structMicroOp_abde81805ed98962f11795e90f070b4ed} 
void Micro\+Op\+::set\+Mem\+Barrier (\begin{DoxyParamCaption}\item[{bool}]{membar}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 201} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ Instruction\+Decoder\+::decode()}, \textbf{ Instruction\+Decoder\+::decode()}, and \textbf{ Micro\+Op\+Performance\+Model\+::\+Micro\+Op\+Performance\+Model()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_abde81805ed98962f11795e90f070b4ed_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!setOperandSize@{setOperandSize}}
\index{setOperandSize@{setOperandSize}!MicroOp@{MicroOp}}
\doxysubsubsection{setOperandSize()}
{\footnotesize\ttfamily \label{structMicroOp_ab66b60b2cf2d9ff56278640f218b625f} 
void Micro\+Op\+::set\+Operand\+Size (\begin{DoxyParamCaption}\item[{int}]{size}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 151} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ operand\+\_\+size}.



Referenced by \textbf{ Instruction\+Decoder\+::decode()}, and \textbf{ Instruction\+Decoder\+::decode()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_ab66b60b2cf2d9ff56278640f218b625f_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!setSerializing@{setSerializing}}
\index{setSerializing@{setSerializing}!MicroOp@{MicroOp}}
\doxysubsubsection{setSerializing()}
{\footnotesize\ttfamily \label{structMicroOp_acb1d247d47bd4fc8b8e5ba00249f824a} 
void Micro\+Op\+::set\+Serializing (\begin{DoxyParamCaption}\item[{bool}]{serializing}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 198} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ serializing}.



Referenced by \textbf{ Instruction\+Decoder\+::decode()}, \textbf{ Instruction\+Decoder\+::decode()}, and \textbf{ Micro\+Op\+Performance\+Model\+::\+Micro\+Op\+Performance\+Model()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_acb1d247d47bd4fc8b8e5ba00249f824a_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!setTypes@{setTypes}}
\index{setTypes@{setTypes}!MicroOp@{MicroOp}}
\doxysubsubsection{setTypes()}
{\footnotesize\ttfamily \label{structMicroOp_a6e72996e6cbfae42bc27fa3d5d26d2cf} 
void Micro\+Op\+::set\+Types (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 145} of file \textbf{ micro\+\_\+op.\+h}.



References \textbf{ get\+Subtype()}, and \textbf{ uop\+\_\+subtype}.



Referenced by \textbf{ make\+Dynamic()}, \textbf{ make\+Execute()}, \textbf{ make\+Load()}, and \textbf{ make\+Store()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=283pt]{structMicroOp_a6e72996e6cbfae42bc27fa3d5d26d2cf_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a6e72996e6cbfae42bc27fa3d5d26d2cf_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!toShortString@{toShortString}}
\index{toShortString@{toShortString}!MicroOp@{MicroOp}}
\doxysubsubsection{toShortString()}
{\footnotesize\ttfamily \label{structMicroOp_a8b964b16a46ccc33b418629b8bbb620c} 
String Micro\+Op\+::to\+Short\+String (\begin{DoxyParamCaption}\item[{bool}]{with\+Disassembly}{ = {\ttfamily false}}\end{DoxyParamCaption}) const}



Definition at line \textbf{ 362} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ Instruction\+::get\+Disassembly()}, \textbf{ get\+Instruction()}, \textbf{ instruction\+Opcode}, \textbf{ UOP\+\_\+\+EXECUTE}, \textbf{ UOP\+\_\+\+LOAD}, \textbf{ UOP\+\_\+\+STORE}, and \textbf{ uop\+\_\+type}.



Referenced by \textbf{ Rob\+Smt\+Timer\+::do\+Commit()}, \textbf{ Rob\+Timer\+::do\+Commit()}, \textbf{ Rob\+Timer\+::do\+Dispatch()}, \textbf{ Rob\+Smt\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Smt\+Timer\+::push\+Instructions()}, \textbf{ Rob\+Timer\+::simulate()}, and \textbf{ Rob\+Smt\+Timer\+::try\+Dispatch()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=330pt]{structMicroOp_a8b964b16a46ccc33b418629b8bbb620c_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structMicroOp_a8b964b16a46ccc33b418629b8bbb620c_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!toString@{toString}}
\index{toString@{toString}!MicroOp@{MicroOp}}
\doxysubsubsection{toString()}
{\footnotesize\ttfamily \label{structMicroOp_ae02f200b7edcc9874e534c8e5772410b} 
String Micro\+Op\+::to\+String (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Definition at line \textbf{ 303} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ get\+Destination\+Registers\+Length()}, \textbf{ get\+Source\+Registers\+Length()}, \textbf{ instruction\+Opcode}, \textbf{ is\+Branch()}, \textbf{ is\+First()}, \textbf{ is\+Interrupt()}, \textbf{ is\+Last()}, \textbf{ is\+Serializing()}, \textbf{ uint32\+\_\+t}, \textbf{ UOP\+\_\+\+EXECUTE}, \textbf{ UOP\+\_\+\+LOAD}, \textbf{ UOP\+\_\+\+STORE}, and \textbf{ uop\+\_\+type}.



Referenced by \textbf{ Windows\+::to\+String()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=332pt]{structMicroOp_ae02f200b7edcc9874e534c8e5772410b_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=265pt]{structMicroOp_ae02f200b7edcc9874e534c8e5772410b_icgraph}
\end{center}
\end{figure}
\index{MicroOp@{MicroOp}!verify@{verify}}
\index{verify@{verify}!MicroOp@{MicroOp}}
\doxysubsubsection{verify()}
{\footnotesize\ttfamily \label{structMicroOp_aecfdfb2a46dd6513e4d1514c0a0d37df} 
void Micro\+Op\+::verify (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Definition at line \textbf{ 203} of file \textbf{ micro\+\_\+op.\+cc}.



References \textbf{ destination\+Registers}, \textbf{ destination\+Registers\+Length}, \textbf{ get\+Subtype()}, \textbf{ LOG\+\_\+\+ASSERT\+\_\+\+ERROR}, \textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+DESTINATION\+\_\+\+REGISTERS}, \textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+SOURCE\+\_\+\+REGISTERS}, \textbf{ source\+Registers}, \textbf{ source\+Registers\+Length}, \textbf{ uint32\+\_\+t}, and \textbf{ uop\+\_\+subtype}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=267pt]{structMicroOp_aecfdfb2a46dd6513e4d1514c0a0d37df_cgraph}
\end{center}
\end{figure}


\doxysubsection{Member Data Documentation}
\index{MicroOp@{MicroOp}!addressRegisters@{addressRegisters}}
\index{addressRegisters@{addressRegisters}!MicroOp@{MicroOp}}
\doxysubsubsection{addressRegisters}
{\footnotesize\ttfamily \label{structMicroOp_aea4b3158eb4d8153209aa7a0fa1cfc70} 
dl\+::\+Decoder\+::decoder\+\_\+reg Micro\+Op\+::address\+Registers[\textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+ADDRESS\+\_\+\+REGISTERS}]}



Definition at line \textbf{ 104} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ add\+Address\+Register()}, and \textbf{ get\+Address\+Register()}.

\index{MicroOp@{MicroOp}!addressRegistersLength@{addressRegistersLength}}
\index{addressRegistersLength@{addressRegistersLength}!MicroOp@{MicroOp}}
\doxysubsubsection{addressRegistersLength}
{\footnotesize\ttfamily \label{structMicroOp_a37596456afb1e59269c514310a757d2f} 
\textbf{ uint32\+\_\+t} Micro\+Op\+::address\+Registers\+Length}

This field contains the length of the destination\+Registers array. 

Definition at line \textbf{ 103} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ add\+Address\+Register()}, \textbf{ get\+Address\+Register()}, and \textbf{ get\+Address\+Registers\+Length()}.

\index{MicroOp@{MicroOp}!branch@{branch}}
\index{branch@{branch}!MicroOp@{MicroOp}}
\doxysubsubsection{branch}
{\footnotesize\ttfamily \label{structMicroOp_af9f5b0997c0240238c24eb2ffb9326c7} 
bool Micro\+Op\+::branch}

Is this instruction a branch ? 

Definition at line \textbf{ 124} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ is\+Branch()}, \textbf{ make\+Dynamic()}, and \textbf{ make\+Execute()}.

\index{MicroOp@{MicroOp}!decodedInstruction@{decodedInstruction}}
\index{decodedInstruction@{decodedInstruction}!MicroOp@{MicroOp}}
\doxysubsubsection{decodedInstruction}
{\footnotesize\ttfamily \label{structMicroOp_a99f767c3f08a47623917a233eacf3075} 
const dl\+::\+Decoded\+Inst$\ast$ Micro\+Op\+::decoded\+Instruction}



Definition at line \textbf{ 85} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ get\+Decoded\+Instruction()}, and \textbf{ set\+Decoded\+Instruction()}.

\index{MicroOp@{MicroOp}!destinationRegisters@{destinationRegisters}}
\index{destinationRegisters@{destinationRegisters}!MicroOp@{MicroOp}}
\doxysubsubsection{destinationRegisters}
{\footnotesize\ttfamily \label{structMicroOp_a1a0d6f8f5f138a4c7d1f67ad8f5b5104} 
dl\+::\+Decoder\+::decoder\+\_\+reg Micro\+Op\+::destination\+Registers[\textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+DESTINATION\+\_\+\+REGISTERS}]}

This array contains the registers written by this Micro\+Operation, the integer is an id given by libdisasm64. Only valid for UOP\+\_\+\+EXECUTE. 

Definition at line \textbf{ 107} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ add\+Destination\+Register()}, \textbf{ get\+Destination\+Register()}, and \textbf{ verify()}.

\index{MicroOp@{MicroOp}!destinationRegistersLength@{destinationRegistersLength}}
\index{destinationRegistersLength@{destinationRegistersLength}!MicroOp@{MicroOp}}
\doxysubsubsection{destinationRegistersLength}
{\footnotesize\ttfamily \label{structMicroOp_a8380a607be90a6f7f8a10066382b1ab1} 
\textbf{ uint32\+\_\+t} Micro\+Op\+::destination\+Registers\+Length}



Definition at line \textbf{ 105} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ add\+Destination\+Register()}, \textbf{ get\+Destination\+Register()}, \textbf{ get\+Destination\+Registers\+Length()}, and \textbf{ verify()}.

\index{MicroOp@{MicroOp}!first@{first}}
\index{first@{first}!MicroOp@{MicroOp}}
\doxysubsubsection{first}
{\footnotesize\ttfamily \label{structMicroOp_a7f8564040a3368a3d1c955e2d4a2f433} 
bool Micro\+Op\+::first}

This micro\+Op is the first micro\+Op of the instruction. 

Definition at line \textbf{ 80} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ is\+First()}, and \textbf{ set\+First()}.

\index{MicroOp@{MicroOp}!instruction@{instruction}}
\index{instruction@{instruction}!MicroOp@{MicroOp}}
\doxysubsubsection{instruction}
{\footnotesize\ttfamily \label{structMicroOp_afeb9078a0872617a881aef8f944de76b} 
\textbf{ Instruction}$\ast$ Micro\+Op\+::instruction}



Definition at line \textbf{ 87} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ get\+Instruction()}, and \textbf{ set\+Instruction()}.

\index{MicroOp@{MicroOp}!instructionOpcode@{instructionOpcode}}
\index{instructionOpcode@{instructionOpcode}!MicroOp@{MicroOp}}
\doxysubsubsection{instructionOpcode}
{\footnotesize\ttfamily \label{structMicroOp_a06e1c9f2f9dc7ddf59cd4f7d8303db3d} 
dl\+::\+Decoder\+::decoder\+\_\+opcode Micro\+Op\+::instruction\+Opcode}



Definition at line \textbf{ 84} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ get\+Instruction\+Opcode()}, \textbf{ make\+Dynamic()}, \textbf{ make\+Execute()}, \textbf{ make\+Load()}, \textbf{ make\+Store()}, \textbf{ to\+Short\+String()}, and \textbf{ to\+String()}.

\index{MicroOp@{MicroOp}!instructionPointer@{instructionPointer}}
\index{instructionPointer@{instructionPointer}!MicroOp@{MicroOp}}
\doxysubsubsection{instructionPointer}
{\footnotesize\ttfamily \label{structMicroOp_ab02f65dbdd9de0b488ea284b66e76baa} 
\textbf{ Memory\+::\+Access} Micro\+Op\+::instruction\+Pointer}

The instruction pointer. 

Definition at line \textbf{ 116} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ get\+Instruction\+Pointer()}.

\index{MicroOp@{MicroOp}!interrupt@{interrupt}}
\index{interrupt@{interrupt}!MicroOp@{MicroOp}}
\doxysubsubsection{interrupt}
{\footnotesize\ttfamily \label{structMicroOp_a9afe8afc9f6a8e76eb73508b8e26b1d5} 
bool Micro\+Op\+::interrupt}

Is this micro\+Op an interrupt ? 

Definition at line \textbf{ 119} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ is\+Interrupt()}, and \textbf{ set\+Interrupt()}.

\index{MicroOp@{MicroOp}!intraInstructionDependencies@{intraInstructionDependencies}}
\index{intraInstructionDependencies@{intraInstructionDependencies}!MicroOp@{MicroOp}}
\doxysubsubsection{intraInstructionDependencies}
{\footnotesize\ttfamily \label{structMicroOp_a0e349a7acf586d08192ae5d64e268b1f} 
\textbf{ uint32\+\_\+t} Micro\+Op\+::intra\+Instruction\+Dependencies}

The intra\+Instruction\+Dependencies variable gives the number of preceding micro\+Op on which this micr\+Op depends. This number is counted from the first micro\+Op with that type. 

Definition at line \textbf{ 96} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ Dynamic\+Micro\+Op\+::\+Dynamic\+Micro\+Op()}, \textbf{ make\+Dynamic()}, \textbf{ make\+Execute()}, \textbf{ make\+Load()}, and \textbf{ make\+Store()}.

\index{MicroOp@{MicroOp}!is\_x87@{is\_x87}}
\index{is\_x87@{is\_x87}!MicroOp@{MicroOp}}
\doxysubsubsection{is\_x87}
{\footnotesize\ttfamily \label{structMicroOp_a29c6358254fbe732a950025ddc3e1fb6} 
bool Micro\+Op\+::is\+\_\+x87}



Definition at line \textbf{ 132} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ is\+X87()}, and \textbf{ set\+Is\+X87()}.

\index{MicroOp@{MicroOp}!last@{last}}
\index{last@{last}!MicroOp@{MicroOp}}
\doxysubsubsection{last}
{\footnotesize\ttfamily \label{structMicroOp_a8802a9575c8887aa86c94c40cca21d24} 
bool Micro\+Op\+::last}

This micro\+Op is the last micro\+Op of the instruction. 

Definition at line \textbf{ 82} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ is\+Last()}, and \textbf{ set\+Last()}.

\index{MicroOp@{MicroOp}!m\_membar@{m\_membar}}
\index{m\_membar@{m\_membar}!MicroOp@{MicroOp}}
\doxysubsubsection{m\_membar}
{\footnotesize\ttfamily \label{structMicroOp_ad32ef0fe607277344cc99110e577dd00} 
bool Micro\+Op\+::m\+\_\+membar}

Debug info about the micro\+Operation. 

Definition at line \textbf{ 131} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ is\+Mem\+Barrier()}.

\index{MicroOp@{MicroOp}!memoryAccessSize@{memoryAccessSize}}
\index{memoryAccessSize@{memoryAccessSize}!MicroOp@{MicroOp}}
\doxysubsubsection{memoryAccessSize}
{\footnotesize\ttfamily \label{structMicroOp_ab911802b83d5535605bbae6c905d7ce3} 
uint16\+\_\+t Micro\+Op\+::memory\+Access\+Size}



Definition at line \textbf{ 134} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ get\+Memory\+Access\+Size()}, \textbf{ make\+Load()}, and \textbf{ make\+Store()}.

\index{MicroOp@{MicroOp}!microOpTypeOffset@{microOpTypeOffset}}
\index{microOpTypeOffset@{microOpTypeOffset}!MicroOp@{MicroOp}}
\doxysubsubsection{microOpTypeOffset}
{\footnotesize\ttfamily \label{structMicroOp_a1c0b2c15b28e514760000e967cd79c2e} 
\textbf{ uint32\+\_\+t} Micro\+Op\+::micro\+Op\+Type\+Offset}

The type\+Offset field contains the offset of the micro\+Op starting from the first micro\+Op with that type. 

Definition at line \textbf{ 94} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ Micro\+Op\+Performance\+Model\+::do\+Squashing()}, \textbf{ Dynamic\+Micro\+Op\+::\+Dynamic\+Micro\+Op()}, \textbf{ make\+Dynamic()}, \textbf{ make\+Execute()}, \textbf{ make\+Load()}, and \textbf{ make\+Store()}.

\index{MicroOp@{MicroOp}!operand\_size@{operand\_size}}
\index{operand\_size@{operand\_size}!MicroOp@{MicroOp}}
\doxysubsubsection{operand\_size}
{\footnotesize\ttfamily \label{structMicroOp_ac8d4eef17f65275e85486cb639d8b762} 
uint16\+\_\+t Micro\+Op\+::operand\+\_\+size}



Definition at line \textbf{ 133} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ get\+Operand\+Size()}, and \textbf{ set\+Operand\+Size()}.

\index{MicroOp@{MicroOp}!serializing@{serializing}}
\index{serializing@{serializing}!MicroOp@{MicroOp}}
\doxysubsubsection{serializing}
{\footnotesize\ttfamily \label{structMicroOp_a68c97ffa821ee1d976d938efb3d0aa13} 
bool Micro\+Op\+::serializing}

Is this micro\+Op serializing ? 

Definition at line \textbf{ 121} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ is\+Serializing()}, and \textbf{ set\+Serializing()}.

\index{MicroOp@{MicroOp}!sourceRegisters@{sourceRegisters}}
\index{sourceRegisters@{sourceRegisters}!MicroOp@{MicroOp}}
\doxysubsubsection{sourceRegisters}
{\footnotesize\ttfamily \label{structMicroOp_abab2f53a9dabfb9a9d7558f263ae39f4} 
dl\+::\+Decoder\+::decoder\+\_\+reg Micro\+Op\+::source\+Registers[\textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+SOURCE\+\_\+\+REGISTERS}]}

This array contains the registers read by this Micro\+Operation, the integer is an id given by libdisasm64. Only valid for UOP\+\_\+\+LOAD and UOP\+\_\+\+EXECUTE. 

Definition at line \textbf{ 101} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ add\+Source\+Register()}, \textbf{ get\+Source\+Register()}, and \textbf{ verify()}.

\index{MicroOp@{MicroOp}!sourceRegistersLength@{sourceRegistersLength}}
\index{sourceRegistersLength@{sourceRegistersLength}!MicroOp@{MicroOp}}
\doxysubsubsection{sourceRegistersLength}
{\footnotesize\ttfamily \label{structMicroOp_a3287853c73e2a6f225ce5efc902776c9} 
\textbf{ uint32\+\_\+t} Micro\+Op\+::source\+Registers\+Length}

This field contains the length of the source\+Registers array. 

Definition at line \textbf{ 99} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ add\+Source\+Register()}, \textbf{ get\+Source\+Register()}, \textbf{ get\+Source\+Registers\+Length()}, and \textbf{ verify()}.

\index{MicroOp@{MicroOp}!uop\_subtype@{uop\_subtype}}
\index{uop\_subtype@{uop\_subtype}!MicroOp@{MicroOp}}
\doxysubsubsection{uop\_subtype}
{\footnotesize\ttfamily \label{structMicroOp_ac73702e06ecdaeca15253b6ec68e35e0} 
\textbf{ uop\+\_\+subtype\+\_\+t} Micro\+Op\+::uop\+\_\+subtype}



Definition at line \textbf{ 77} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ Dynamic\+Micro\+Op\+Nehalem\+::get\+Port()}, \textbf{ get\+Subtype()}, \textbf{ get\+Subtype\+String()}, \textbf{ set\+Types()}, and \textbf{ verify()}.

\index{MicroOp@{MicroOp}!uop\_type@{uop\_type}}
\index{uop\_type@{uop\_type}!MicroOp@{MicroOp}}
\doxysubsubsection{uop\_type}
{\footnotesize\ttfamily \label{structMicroOp_a03b91a72af77a535c502d4b06eeb130c} 
\textbf{ uop\+\_\+type\+\_\+t} Micro\+Op\+::uop\+\_\+type}

The micro\+Operation type. 

Definition at line \textbf{ 66} of file \textbf{ micro\+\_\+op.\+h}.



Referenced by \textbf{ Dynamic\+Micro\+Op\+Boom\+V1\+::get\+Alu()}, \textbf{ Dynamic\+Micro\+Op\+Nehalem\+::get\+Alu()}, \textbf{ get\+Type()}, \textbf{ is\+Execute()}, \textbf{ make\+Dynamic()}, \textbf{ make\+Execute()}, \textbf{ make\+Load()}, \textbf{ make\+Store()}, \textbf{ to\+Short\+String()}, and \textbf{ to\+String()}.



The documentation for this struct was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
common/performance\+\_\+model/performance\+\_\+models/micro\+\_\+op/\textbf{ micro\+\_\+op.\+h}\item 
common/performance\+\_\+model/performance\+\_\+models/micro\+\_\+op/\textbf{ micro\+\_\+op.\+cc}\end{DoxyCompactItemize}
