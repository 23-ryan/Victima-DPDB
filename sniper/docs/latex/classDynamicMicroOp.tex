\doxysection{Dynamic\+Micro\+Op Class Reference}
\label{classDynamicMicroOp}\index{DynamicMicroOp@{DynamicMicroOp}}


{\ttfamily \#include $<$dynamic\+\_\+micro\+\_\+op.\+h$>$}



Inheritance diagram for Dynamic\+Micro\+Op\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=320pt]{classDynamicMicroOp__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Dynamic\+Micro\+Op\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp__coll__graph}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Dynamic\+Micro\+Op} (const \textbf{ Micro\+Op} $\ast$uop, const \textbf{ Core\+Model} $\ast$core\+\_\+model, \textbf{ Component\+Period} period)
\item 
virtual \textbf{ $\sim$\+Dynamic\+Micro\+Op} ()
\item 
const \textbf{ Micro\+Op} $\ast$ \textbf{ get\+Micro\+Op} () const
\item 
{\footnotesize template$<$typename T $>$ }\\const T $\ast$ \textbf{ get\+Core\+Specific\+Info} () const
\item 
void \textbf{ squash} (std\+::vector$<$ \textbf{ Dynamic\+Micro\+Op} $\ast$ $>$ $\ast$array=NULL)
\item 
bool \textbf{ is\+Squashed} ()
\item 
\textbf{ uint32\+\_\+t} \textbf{ get\+Dependencies\+Length} () const
\item 
\textbf{ uint64\+\_\+t} \textbf{ get\+Dependency} (\textbf{ uint32\+\_\+t} index) const
\item 
void \textbf{ add\+Dependency} (\textbf{ uint64\+\_\+t} \textbf{ sequence\+Number})
\item 
void \textbf{ remove\+Dependency} (\textbf{ uint64\+\_\+t} \textbf{ sequence\+Number})
\item 
\textbf{ uint32\+\_\+t} \textbf{ get\+Intra\+Instr\+Dependencies\+Length} () const
\item 
void \textbf{ set\+Intra\+Instr\+Dependencies\+Length} (\textbf{ uint32\+\_\+t} deps)
\item 
\textbf{ uint32\+\_\+t} \textbf{ get\+Micro\+Op\+Type\+Offset} () const
\item 
void \textbf{ set\+Micro\+Op\+Type\+Offset} (\textbf{ uint32\+\_\+t} offset)
\item 
\textbf{ uint32\+\_\+t} \textbf{ get\+Squashed\+Count} () const
\item 
void \textbf{ set\+Squashed\+Count} (\textbf{ uint32\+\_\+t} count)
\item 
void \textbf{ set\+First} (bool \+\_\+first)
\item 
bool \textbf{ is\+First} () const
\item 
void \textbf{ set\+Last} (bool \+\_\+last)
\item 
bool \textbf{ is\+Last} () const
\item 
bool \textbf{ is\+Branch\+Taken} () const
\item 
void \textbf{ set\+Branch\+Taken} (bool \+\_\+branch\+\_\+taken)
\item 
bool \textbf{ is\+Branch\+Mispredicted} () const
\item 
void \textbf{ set\+Branch\+Mispredicted} (bool mispredicted)
\item 
\textbf{ Int\+Ptr} \textbf{ get\+Branch\+Target} () const
\item 
void \textbf{ set\+Branch\+Target} (\textbf{ Int\+Ptr} \textbf{ address})
\item 
const \textbf{ Memory\+::\+Access} \& \textbf{ get\+Load\+Access} () const
\item 
bool \textbf{ is\+Long\+Latency\+Load} () const
\item 
const \textbf{ Memory\+::\+Access} \& \textbf{ get\+Store\+Access} () const
\item 
\textbf{ uint32\+\_\+t} \textbf{ get\+Exec\+Latency} () const
\item 
void \textbf{ set\+Exec\+Latency} (\textbf{ uint32\+\_\+t} latency)
\item 
\textbf{ uint64\+\_\+t} \textbf{ get\+Sequence\+Number} () const
\item 
void \textbf{ set\+Sequence\+Number} (\textbf{ uint64\+\_\+t} number)
\item 
\textbf{ Hit\+Where\+::where\+\_\+t} \textbf{ get\+DCache\+Hit\+Where} () const
\item 
void \textbf{ set\+DCache\+Hit\+Where} (\textbf{ Hit\+Where\+::where\+\_\+t} \+\_\+hit\+Where)
\item 
\textbf{ Hit\+Where\+::where\+\_\+t} \textbf{ get\+ICache\+Hit\+Where} () const
\item 
void \textbf{ set\+ICache\+Hit\+Where} (\textbf{ Hit\+Where\+::where\+\_\+t} \+\_\+hit\+Where)
\item 
\textbf{ uint32\+\_\+t} \textbf{ get\+ICache\+Latency} () const
\item 
void \textbf{ set\+ICache\+Latency} (\textbf{ uint32\+\_\+t} \+\_\+latency)
\item 
void \textbf{ set\+Address} (const \textbf{ Memory\+::\+Access} \&load\+Access)
\item 
const \textbf{ Memory\+::\+Access} \& \textbf{ get\+Address} (void) const
\item 
void \textbf{ set\+Force\+Long\+Latency\+Load} (bool force\+LLL)
\item 
\textbf{ Subsecond\+Time} \textbf{ get\+Period} () const
\item 
virtual const char $\ast$ \textbf{ get\+Type} () const =0
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T $>$ }\\static T $\ast$ \textbf{ alloc} (\textbf{ Allocator} $\ast$alloc, const \textbf{ Micro\+Op} $\ast$uop, const \textbf{ Core\+Model} $\ast$core\+\_\+model, \textbf{ Component\+Period} period)
\item 
static void \textbf{ operator delete} (void $\ast$ptr)
\end{DoxyCompactItemize}
\doxysubsubsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
const \textbf{ Micro\+Op} $\ast$ \textbf{ m\+\_\+uop}
\item 
const \textbf{ Core\+Model} $\ast$ \textbf{ m\+\_\+core\+\_\+model}
\item 
const \textbf{ Subsecond\+Time} \textbf{ m\+\_\+period}
\item 
\textbf{ uint64\+\_\+t} \textbf{ sequence\+Number}
\item 
\textbf{ Memory\+::\+Access} \textbf{ address}
\item 
bool \textbf{ squashed}
\item 
\textbf{ uint32\+\_\+t} \textbf{ intra\+Instruction\+Dependencies}
\item 
\textbf{ uint32\+\_\+t} \textbf{ micro\+Op\+Type\+Offset}
\item 
\textbf{ uint32\+\_\+t} \textbf{ squashed\+Count}
\item 
\textbf{ uint32\+\_\+t} \textbf{ dependencies\+Length}
\item 
\textbf{ uint64\+\_\+t} \textbf{ dependencies} [\textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+DEPENDENCIES}]
\item 
\textbf{ uint32\+\_\+t} \textbf{ exec\+Latency}
\item 
bool \textbf{ branch\+Taken}
\item 
bool \textbf{ branch\+Mispredicted}
\item 
\textbf{ Int\+Ptr} \textbf{ branch\+Target\+Address}
\item 
\textbf{ Hit\+Where\+::where\+\_\+t} \textbf{ d\+Cache\+Hit\+Where}
\item 
\textbf{ Hit\+Where\+::where\+\_\+t} \textbf{ i\+Cache\+Hit\+Where}
\item 
\textbf{ uint32\+\_\+t} \textbf{ i\+Cache\+Latency}
\item 
bool \textbf{ m\+\_\+force\+Long\+Latency\+Load}
\item 
bool \textbf{ first}
\item 
bool \textbf{ last}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}


Definition at line \textbf{ 14} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



\doxysubsection{Constructor \& Destructor Documentation}
\index{DynamicMicroOp@{DynamicMicroOp}!DynamicMicroOp@{DynamicMicroOp}}
\index{DynamicMicroOp@{DynamicMicroOp}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{DynamicMicroOp()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a577c00a0a52283bd596c93f45d12665a} 
Dynamic\+Micro\+Op\+::\+Dynamic\+Micro\+Op (\begin{DoxyParamCaption}\item[{const \textbf{ Micro\+Op} $\ast$}]{uop}{, }\item[{const \textbf{ Core\+Model} $\ast$}]{core\+\_\+model}{, }\item[{\textbf{ Component\+Period}}]{period}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 5} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+cc}.



References \textbf{ branch\+Mispredicted}, \textbf{ branch\+Taken}, \textbf{ d\+Cache\+Hit\+Where}, \textbf{ dependencies}, \textbf{ dependencies\+Length}, \textbf{ exec\+Latency}, \textbf{ first}, \textbf{ Core\+Model\+::get\+Instruction\+Latency()}, \textbf{ i\+Cache\+Hit\+Where}, \textbf{ i\+Cache\+Latency}, \textbf{ intra\+Instruction\+Dependencies}, \textbf{ Micro\+Op\+::intra\+Instruction\+Dependencies}, \textbf{ INVALID\+\_\+\+SEQNR}, \textbf{ Micro\+Op\+::is\+First()}, \textbf{ Micro\+Op\+::is\+Last()}, \textbf{ Hit\+Where\+::\+L1I}, \textbf{ last}, \textbf{ LOG\+\_\+\+ASSERT\+\_\+\+ERROR}, \textbf{ m\+\_\+core\+\_\+model}, \textbf{ m\+\_\+force\+Long\+Latency\+Load}, \textbf{ m\+\_\+uop}, \textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+DEPENDENCIES}, \textbf{ micro\+Op\+Type\+Offset}, \textbf{ Micro\+Op\+::micro\+Op\+Type\+Offset}, \textbf{ sequence\+Number}, \textbf{ squashed}, \textbf{ squashed\+Count}, \textbf{ uint32\+\_\+t}, \textbf{ Hit\+Where\+::\+UNKNOWN}, and \textbf{ Subsecond\+Time\+::\+Zero()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a577c00a0a52283bd596c93f45d12665a_cgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!````~DynamicMicroOp@{$\sim$DynamicMicroOp}}
\index{````~DynamicMicroOp@{$\sim$DynamicMicroOp}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{$\sim$DynamicMicroOp()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a83918c8710c0f0098f1c6a1e6ad00905} 
Dynamic\+Micro\+Op\+::$\sim$\+Dynamic\+Micro\+Op (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Definition at line \textbf{ 41} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+cc}.



\doxysubsection{Member Function Documentation}
\index{DynamicMicroOp@{DynamicMicroOp}!addDependency@{addDependency}}
\index{addDependency@{addDependency}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{addDependency()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a4cdf0720211507ce0eb17e6fde56f525} 
void Dynamic\+Micro\+Op\+::add\+Dependency (\begin{DoxyParamCaption}\item[{\textbf{ uint64\+\_\+t}}]{sequence\+Number}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 77} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+cc}.



References \textbf{ Tools\+::contains()}, \textbf{ dependencies}, \textbf{ dependencies\+Length}, \textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+DEPENDENCIES}, and \textbf{ sequence\+Number}.



Referenced by \textbf{ Memory\+Dependencies\+::set\+Dependencies()}, \textbf{ Register\+Dependencies\+::set\+Dependencies()}, \textbf{ Rob\+Smt\+Timer\+::set\+Dependencies()}, and \textbf{ Rob\+Timer\+::simulate()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=325pt]{classDynamicMicroOp_a4cdf0720211507ce0eb17e6fde56f525_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a4cdf0720211507ce0eb17e6fde56f525_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!alloc@{alloc}}
\index{alloc@{alloc}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{alloc()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_aeb8c8bf012fc6c5f2e752e49dc3c6cb4} 
template$<$typename T $>$ \\
static T $\ast$ Dynamic\+Micro\+Op\+::alloc (\begin{DoxyParamCaption}\item[{\textbf{ Allocator} $\ast$}]{alloc}{, }\item[{const \textbf{ Micro\+Op} $\ast$}]{uop}{, }\item[{const \textbf{ Core\+Model} $\ast$}]{core\+\_\+model}{, }\item[{\textbf{ Component\+Period}}]{period}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Definition at line \textbf{ 74} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ alloc()}.



Referenced by \textbf{ alloc()}, \textbf{ Base\+Core\+Model$<$ T $>$\+::create\+Dynamic\+Micro\+Op()}, \textbf{ Core\+Model\+Boom\+V1\+::create\+Dynamic\+Micro\+Op()}, and \textbf{ Core\+Model\+Nehalem\+::create\+Dynamic\+Micro\+Op()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=159pt]{classDynamicMicroOp_aeb8c8bf012fc6c5f2e752e49dc3c6cb4_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_aeb8c8bf012fc6c5f2e752e49dc3c6cb4_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!getAddress@{getAddress}}
\index{getAddress@{getAddress}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{getAddress()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a800f17043866d3a011b2743863f1ee78} 
const \textbf{ Memory\+::\+Access} \& Dynamic\+Micro\+Op\+::get\+Address (\begin{DoxyParamCaption}\item[{void}]{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 142} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ address}.



Referenced by \textbf{ Rob\+Smt\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Timer\+::issue\+Instruction()}, \textbf{ Interval\+Timer\+::issue\+Mem\+Op()}, \textbf{ Rob\+Smt\+Timer\+::print\+Rob()}, and \textbf{ Rob\+Timer\+::print\+Rob()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a800f17043866d3a011b2743863f1ee78_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!getBranchTarget@{getBranchTarget}}
\index{getBranchTarget@{getBranchTarget}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{getBranchTarget()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_ad42d6f9076b300b80d46d991da65ff8a} 
\textbf{ Int\+Ptr} Dynamic\+Micro\+Op\+::get\+Branch\+Target (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 118} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ branch\+Target\+Address}, \textbf{ Micro\+Op\+::is\+Branch()}, \textbf{ LOG\+\_\+\+ASSERT\+\_\+\+ERROR}, and \textbf{ m\+\_\+uop}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=315pt]{classDynamicMicroOp_ad42d6f9076b300b80d46d991da65ff8a_cgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!getCoreSpecificInfo@{getCoreSpecificInfo}}
\index{getCoreSpecificInfo@{getCoreSpecificInfo}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{getCoreSpecificInfo()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_aa428e4258c6aff9ad5f1a3aa37229c55} 
template$<$typename T $>$ \\
const T $\ast$ Dynamic\+Micro\+Op\+::get\+Core\+Specific\+Info (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 84} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ get\+Type()}, and \textbf{ LOG\+\_\+\+ASSERT\+\_\+\+ERROR}.



Referenced by \textbf{ Interval\+Contention\+Boom\+V1\+::add\+Functional\+Unit\+Stats()}, \textbf{ Interval\+Contention\+Nehalem\+::add\+Functional\+Unit\+Stats()}, \textbf{ Rob\+Contention\+Boom\+V1\+::do\+Issue()}, \textbf{ Rob\+Contention\+Nehalem\+::do\+Issue()}, \textbf{ Core\+Model\+Boom\+V1\+::get\+Bypass\+Latency()}, \textbf{ Core\+Model\+Nehalem\+::get\+Bypass\+Latency()}, \textbf{ Interval\+Contention\+Boom\+V1\+::remove\+Functional\+Unit\+Stats()}, \textbf{ Interval\+Contention\+Nehalem\+::remove\+Functional\+Unit\+Stats()}, \textbf{ Rob\+Contention\+Boom\+V1\+::try\+Issue()}, and \textbf{ Rob\+Contention\+Nehalem\+::try\+Issue()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_aa428e4258c6aff9ad5f1a3aa37229c55_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_aa428e4258c6aff9ad5f1a3aa37229c55_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!getDCacheHitWhere@{getDCacheHitWhere}}
\index{getDCacheHitWhere@{getDCacheHitWhere}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{getDCacheHitWhere()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a22f6d859c3220a65305666d52c73b158} 
\textbf{ Hit\+Where\+::where\+\_\+t} Dynamic\+Micro\+Op\+::get\+DCache\+Hit\+Where (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 131} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ d\+Cache\+Hit\+Where}.



Referenced by \textbf{ Rob\+Smt\+Timer\+::count\+Outstanding\+Memop()}, \textbf{ Rob\+Timer\+::count\+Outstanding\+Memop()}, \textbf{ Interval\+Timer\+::dispatch\+Instruction()}, \textbf{ Rob\+Timer\+::do\+Issue()}, \textbf{ Rob\+Smt\+Timer\+::find\+Cpi\+Component()}, \textbf{ Rob\+Timer\+::find\+Cpi\+Component()}, \textbf{ get\+Cp\+Contr\+Type()}, \textbf{ Rob\+Smt\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Timer\+::issue\+Instruction()}, \textbf{ Interval\+Timer\+::issue\+Mem\+Op()}, and \textbf{ Rob\+Smt\+Timer\+::try\+Issue()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a22f6d859c3220a65305666d52c73b158_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!getDependenciesLength@{getDependenciesLength}}
\index{getDependenciesLength@{getDependenciesLength}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{getDependenciesLength()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a631a83f866d0b2dcd02f7c48eef1fe1d} 
\textbf{ uint32\+\_\+t} Dynamic\+Micro\+Op\+::get\+Dependencies\+Length (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 94} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ dependencies\+Length}.



Referenced by \textbf{ Rob\+Smt\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Smt\+Timer\+::print\+Rob()}, \textbf{ Rob\+Timer\+::print\+Rob()}, \textbf{ Rob\+Smt\+Timer\+::set\+Dependencies()}, and \textbf{ Rob\+Timer\+::simulate()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a631a83f866d0b2dcd02f7c48eef1fe1d_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!getDependency@{getDependency}}
\index{getDependency@{getDependency}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{getDependency()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a872433accfe628cf6277f1ba7ce59e2a} 
\textbf{ uint64\+\_\+t} Dynamic\+Micro\+Op\+::get\+Dependency (\begin{DoxyParamCaption}\item[{\textbf{ uint32\+\_\+t}}]{index}{}\end{DoxyParamCaption}) const}



Definition at line \textbf{ 67} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+cc}.



References \textbf{ dependencies}, \textbf{ dependencies\+Length}, \textbf{ intra\+Instruction\+Dependencies}, \textbf{ micro\+Op\+Type\+Offset}, and \textbf{ sequence\+Number}.



Referenced by \textbf{ Interval\+Timer\+::block\+Window()}, \textbf{ Windows\+::calculate\+Branch\+Resolution\+Latency()}, \textbf{ Interval\+Timer\+::get\+Max\+Producer\+Exec\+Time()}, \textbf{ Rob\+Smt\+Timer\+::print\+Rob()}, \textbf{ Rob\+Timer\+::print\+Rob()}, \textbf{ Rob\+Smt\+Timer\+::set\+Dependencies()}, and \textbf{ Rob\+Timer\+::simulate()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a872433accfe628cf6277f1ba7ce59e2a_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!getExecLatency@{getExecLatency}}
\index{getExecLatency@{getExecLatency}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{getExecLatency()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a1c98e478aa3cd0a0ed3de6f29b9cc02e} 
\textbf{ uint32\+\_\+t} Dynamic\+Micro\+Op\+::get\+Exec\+Latency (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 125} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ exec\+Latency}.



Referenced by \textbf{ Interval\+Timer\+::block\+Window()}, \textbf{ Windows\+::calculate\+Branch\+Resolution\+Latency()}, \textbf{ Interval\+Timer\+::dispatch\+Instruction()}, \textbf{ Interval\+Timer\+::get\+Max\+Producer\+Exec\+Time()}, \textbf{ Rob\+Smt\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Timer\+::issue\+Instruction()}, \textbf{ Interval\+Timer\+::issue\+Mem\+Op()}, \textbf{ Rob\+Smt\+Timer\+::print\+Rob()}, and \textbf{ Rob\+Timer\+::print\+Rob()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a1c98e478aa3cd0a0ed3de6f29b9cc02e_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!getICacheHitWhere@{getICacheHitWhere}}
\index{getICacheHitWhere@{getICacheHitWhere}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{getICacheHitWhere()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a2b6907cb77861e89f07d59f57d838446} 
\textbf{ Hit\+Where\+::where\+\_\+t} Dynamic\+Micro\+Op\+::get\+ICache\+Hit\+Where (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 134} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ i\+Cache\+Hit\+Where}.



Referenced by \textbf{ Interval\+Timer\+::dispatch\+Instruction()}, \textbf{ Rob\+Timer\+::do\+Dispatch()}, and \textbf{ Rob\+Smt\+Timer\+::try\+Dispatch()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a2b6907cb77861e89f07d59f57d838446_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!getICacheLatency@{getICacheLatency}}
\index{getICacheLatency@{getICacheLatency}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{getICacheLatency()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_aa11002fc6dc52b1ad11dd385e6d6b2d1} 
\textbf{ uint32\+\_\+t} Dynamic\+Micro\+Op\+::get\+ICache\+Latency (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 137} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ i\+Cache\+Latency}.



Referenced by \textbf{ Interval\+Timer\+::dispatch\+Instruction()}, \textbf{ Rob\+Timer\+::do\+Dispatch()}, and \textbf{ Rob\+Smt\+Timer\+::try\+Dispatch()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_aa11002fc6dc52b1ad11dd385e6d6b2d1_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!getIntraInstrDependenciesLength@{getIntraInstrDependenciesLength}}
\index{getIntraInstrDependenciesLength@{getIntraInstrDependenciesLength}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{getIntraInstrDependenciesLength()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a2db73b02252d1ca9bf960429c2acd7ec} 
\textbf{ uint32\+\_\+t} Dynamic\+Micro\+Op\+::get\+Intra\+Instr\+Dependencies\+Length (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 99} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ intra\+Instruction\+Dependencies}.



Referenced by \textbf{ Micro\+Op\+Performance\+Model\+::do\+Squashing()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a2db73b02252d1ca9bf960429c2acd7ec_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!getLoadAccess@{getLoadAccess}}
\index{getLoadAccess@{getLoadAccess}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{getLoadAccess()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a9198e103022bb20a30c77d82ffb0e0ac} 
const \textbf{ Memory\+::\+Access} \& Dynamic\+Micro\+Op\+::get\+Load\+Access (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Definition at line \textbf{ 116} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+cc}.



References \textbf{ address}, and \textbf{ get\+Micro\+Op()}.



Referenced by \textbf{ Interval\+Timer\+::block\+Window()}, and \textbf{ Memory\+Dependencies\+::set\+Dependencies()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a9198e103022bb20a30c77d82ffb0e0ac_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a9198e103022bb20a30c77d82ffb0e0ac_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!getMicroOp@{getMicroOp}}
\index{getMicroOp@{getMicroOp}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{getMicroOp()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_aa0cb40dd89a322aadf58e9fb03b6449a} 
const \textbf{ Micro\+Op} $\ast$ Dynamic\+Micro\+Op\+::get\+Micro\+Op (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 82} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ m\+\_\+uop}.



Referenced by \textbf{ Rob\+Smt\+Timer\+::count\+Outstanding\+Memop()}, \textbf{ Rob\+Timer\+::count\+Outstanding\+Memop()}, \textbf{ Rob\+Smt\+Timer\+::do\+Commit()}, \textbf{ Rob\+Timer\+::do\+Commit()}, \textbf{ Rob\+Timer\+::do\+Dispatch()}, \textbf{ Rob\+Contention\+Boom\+V1\+::do\+Issue()}, \textbf{ Rob\+Contention\+Nehalem\+::do\+Issue()}, \textbf{ Rob\+Timer\+::do\+Issue()}, \textbf{ Micro\+Op\+Performance\+Model\+::do\+Squashing()}, \textbf{ Rob\+Smt\+Timer\+::find\+Cpi\+Component()}, \textbf{ Rob\+Timer\+::find\+Cpi\+Component()}, \textbf{ get\+Load\+Access()}, \textbf{ Windows\+::\+Window\+Entry\+::get\+Micro\+Op()}, \textbf{ get\+Store\+Access()}, \textbf{ is\+Long\+Latency\+Load()}, \textbf{ Rob\+Smt\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Smt\+Timer\+::print\+Rob()}, \textbf{ Rob\+Timer\+::print\+Rob()}, \textbf{ Rob\+Smt\+Timer\+::push\+Instructions()}, \textbf{ Memory\+Dependencies\+::set\+Dependencies()}, \textbf{ Register\+Dependencies\+::set\+Dependencies()}, \textbf{ Rob\+Smt\+Timer\+::set\+Dependencies()}, \textbf{ Rob\+Smt\+Timer\+::set\+Store\+Address\+Producers()}, \textbf{ Rob\+Timer\+::simulate()}, \textbf{ Instruction\+Tracer\+FPStats\+::trace\+Instruction()}, \textbf{ Instruction\+Tracer\+Print\+::trace\+Instruction()}, \textbf{ Loop\+Profiler\+::trace\+Instruction()}, \textbf{ Loop\+Tracer\+::trace\+Instruction()}, \textbf{ Rob\+Smt\+Timer\+::try\+Dispatch()}, and \textbf{ Rob\+Smt\+Timer\+::try\+Issue()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_aa0cb40dd89a322aadf58e9fb03b6449a_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!getMicroOpTypeOffset@{getMicroOpTypeOffset}}
\index{getMicroOpTypeOffset@{getMicroOpTypeOffset}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{getMicroOpTypeOffset()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a39f7fa67c30343877b7b5c848c9f939e} 
\textbf{ uint32\+\_\+t} Dynamic\+Micro\+Op\+::get\+Micro\+Op\+Type\+Offset (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 102} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ micro\+Op\+Type\+Offset}.

\index{DynamicMicroOp@{DynamicMicroOp}!getPeriod@{getPeriod}}
\index{getPeriod@{getPeriod}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{getPeriod()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a6978d6c9616f5f84a596f2f177abde55} 
\textbf{ Subsecond\+Time} Dynamic\+Micro\+Op\+::get\+Period (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 146} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ LOG\+\_\+\+ASSERT\+\_\+\+ERROR}, \textbf{ m\+\_\+period}, and \textbf{ Subsecond\+Time\+::\+Zero()}.



Referenced by \textbf{ Interval\+Timer\+::dispatch\+Instruction()}, \textbf{ Interval\+Timer\+::dispatch\+Window()}, and \textbf{ Interval\+Timer\+::update\+Critical\+Path()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a6978d6c9616f5f84a596f2f177abde55_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a6978d6c9616f5f84a596f2f177abde55_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!getSequenceNumber@{getSequenceNumber}}
\index{getSequenceNumber@{getSequenceNumber}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{getSequenceNumber()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a7ae4187e4b2717f826f8dd3a07061db8} 
\textbf{ uint64\+\_\+t} Dynamic\+Micro\+Op\+::get\+Sequence\+Number (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 128} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ sequence\+Number}.



Referenced by \textbf{ Rob\+Smt\+Timer\+::find\+Entry\+By\+Sequence\+Number()}, \textbf{ Rob\+Timer\+::find\+Entry\+By\+Sequence\+Number()}, \textbf{ Windows\+::\+Window\+Entry\+::get\+Sequence\+Number()}, \textbf{ Rob\+Smt\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Smt\+Timer\+::print\+Rob()}, \textbf{ Rob\+Timer\+::print\+Rob()}, \textbf{ Memory\+Dependencies\+::set\+Dependencies()}, \textbf{ Register\+Dependencies\+::set\+Dependencies()}, \textbf{ Rob\+Smt\+Timer\+::set\+Dependencies()}, and \textbf{ Rob\+Timer\+::simulate()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a7ae4187e4b2717f826f8dd3a07061db8_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!getSquashedCount@{getSquashedCount}}
\index{getSquashedCount@{getSquashedCount}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{getSquashedCount()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a7d741ddd0537d8e84f8a5fcf1da274f6} 
\textbf{ uint32\+\_\+t} Dynamic\+Micro\+Op\+::get\+Squashed\+Count (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 105} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ squashed\+Count}.

\index{DynamicMicroOp@{DynamicMicroOp}!getStoreAccess@{getStoreAccess}}
\index{getStoreAccess@{getStoreAccess}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{getStoreAccess()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a6d0c46351622a8d4c6ec9abead3dedf6} 
const \textbf{ Memory\+::\+Access} \& Dynamic\+Micro\+Op\+::get\+Store\+Access (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Definition at line \textbf{ 122} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+cc}.



References \textbf{ address}, and \textbf{ get\+Micro\+Op()}.



Referenced by \textbf{ Memory\+Dependencies\+::set\+Dependencies()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a6d0c46351622a8d4c6ec9abead3dedf6_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a6d0c46351622a8d4c6ec9abead3dedf6_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!getType@{getType}}
\index{getType@{getType}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{getType()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a5d53ded87782dfa2ca0dc4af8b1796a4} 
virtual const char $\ast$ Dynamic\+Micro\+Op\+::get\+Type (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}



Implemented in \textbf{ Dynamic\+Micro\+Op\+Boom\+V1} \doxyref{}{p.}{classDynamicMicroOpBoomV1_ad65489644f328f4b65624567a99ccac6}, and \textbf{ Dynamic\+Micro\+Op\+Nehalem} \doxyref{}{p.}{classDynamicMicroOpNehalem_a7fafa057a1df290920d162156d710111}.



Referenced by \textbf{ get\+Core\+Specific\+Info()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a5d53ded87782dfa2ca0dc4af8b1796a4_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!isBranchMispredicted@{isBranchMispredicted}}
\index{isBranchMispredicted@{isBranchMispredicted}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{isBranchMispredicted()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a81776d1befb169781715b266db2d27b5} 
bool Dynamic\+Micro\+Op\+::is\+Branch\+Mispredicted (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 116} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ branch\+Mispredicted}, \textbf{ Micro\+Op\+::is\+Branch()}, \textbf{ LOG\+\_\+\+ASSERT\+\_\+\+ERROR}, and \textbf{ m\+\_\+uop}.



Referenced by \textbf{ Interval\+Timer\+::dispatch\+Instruction()}, \textbf{ Rob\+Timer\+::do\+Dispatch()}, \textbf{ Rob\+Smt\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Timer\+::issue\+Instruction()}, and \textbf{ Rob\+Smt\+Timer\+::try\+Dispatch()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=309pt]{classDynamicMicroOp_a81776d1befb169781715b266db2d27b5_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a81776d1befb169781715b266db2d27b5_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!isBranchTaken@{isBranchTaken}}
\index{isBranchTaken@{isBranchTaken}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{isBranchTaken()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_aedb6172cf86ae709aeda54a9bb757fb3} 
bool Dynamic\+Micro\+Op\+::is\+Branch\+Taken (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 114} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ branch\+Taken}, \textbf{ Micro\+Op\+::is\+Branch()}, \textbf{ LOG\+\_\+\+ASSERT\+\_\+\+ERROR}, and \textbf{ m\+\_\+uop}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=309pt]{classDynamicMicroOp_aedb6172cf86ae709aeda54a9bb757fb3_cgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!isFirst@{isFirst}}
\index{isFirst@{isFirst}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{isFirst()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a7f6912012ef5238ea12deedd58a845cf} 
bool Dynamic\+Micro\+Op\+::is\+First (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 109} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ first}.



Referenced by \textbf{ Loop\+Tracer\+::trace\+Instruction()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=339pt]{classDynamicMicroOp_a7f6912012ef5238ea12deedd58a845cf_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!isLast@{isLast}}
\index{isLast@{isLast}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{isLast()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a3c0010c414acbdd90d4996edf79b7bf8} 
bool Dynamic\+Micro\+Op\+::is\+Last (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 112} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ last}.



Referenced by \textbf{ Interval\+Timer\+::dispatch\+Window()}, \textbf{ Rob\+Smt\+Timer\+::do\+Commit()}, \textbf{ Rob\+Timer\+::do\+Commit()}, \textbf{ Rob\+Timer\+::do\+Dispatch()}, and \textbf{ Rob\+Smt\+Timer\+::try\+Dispatch()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a3c0010c414acbdd90d4996edf79b7bf8_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!isLongLatencyLoad@{isLongLatencyLoad}}
\index{isLongLatencyLoad@{isLongLatencyLoad}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{isLongLatencyLoad()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_af57007331c71c8b518f6b780201701e2} 
bool Dynamic\+Micro\+Op\+::is\+Long\+Latency\+Load (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const}



Definition at line \textbf{ 128} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+cc}.



References \textbf{ exec\+Latency}, \textbf{ Core\+Model\+::get\+Long\+Latency\+Cutoff()}, \textbf{ get\+Micro\+Op()}, \textbf{ LOG\+\_\+\+ASSERT\+\_\+\+ERROR}, \textbf{ m\+\_\+core\+\_\+model}, \textbf{ m\+\_\+force\+Long\+Latency\+Load}, and \textbf{ uint32\+\_\+t}.



Referenced by \textbf{ Interval\+Timer\+::block\+Window()}, \textbf{ Interval\+Timer\+::dispatch\+Instruction()}, \textbf{ Rob\+Timer\+::do\+Issue()}, and \textbf{ Rob\+Smt\+Timer\+::try\+Issue()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_af57007331c71c8b518f6b780201701e2_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_af57007331c71c8b518f6b780201701e2_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!isSquashed@{isSquashed}}
\index{isSquashed@{isSquashed}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{isSquashed()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a05c05b16007649709c4d7aaf6a4fdfed} 
bool Dynamic\+Micro\+Op\+::is\+Squashed (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 92} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ squashed}.



Referenced by \textbf{ Micro\+Op\+Performance\+Model\+::do\+Squashing()}, and \textbf{ squash()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a05c05b16007649709c4d7aaf6a4fdfed_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!operator delete@{operator delete}}
\index{operator delete@{operator delete}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{operator delete()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_af907e159e05172dc4e7104155af61aaf} 
static void Dynamic\+Micro\+Op\+::operator delete (\begin{DoxyParamCaption}\item[{void $\ast$}]{ptr}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Definition at line \textbf{ 80} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ Allocator\+::dealloc()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_af907e159e05172dc4e7104155af61aaf_cgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!removeDependency@{removeDependency}}
\index{removeDependency@{removeDependency}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{removeDependency()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a7357fdb5b1f17acde74a23e57e930264} 
void Dynamic\+Micro\+Op\+::remove\+Dependency (\begin{DoxyParamCaption}\item[{\textbf{ uint64\+\_\+t}}]{sequence\+Number}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 86} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+cc}.



References \textbf{ dependencies}, \textbf{ dependencies\+Length}, \textbf{ Tools\+::index()}, \textbf{ intra\+Instruction\+Dependencies}, \textbf{ LOG\+\_\+\+ASSERT\+\_\+\+ERROR}, \textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+DEPENDENCIES}, \textbf{ micro\+Op\+Type\+Offset}, \textbf{ sequence\+Number}, \textbf{ Tools\+::swap()}, and \textbf{ uint64\+\_\+t}.



Referenced by \textbf{ Rob\+Smt\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Smt\+Timer\+::set\+Dependencies()}, and \textbf{ Rob\+Timer\+::simulate()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=328pt]{classDynamicMicroOp_a7357fdb5b1f17acde74a23e57e930264_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a7357fdb5b1f17acde74a23e57e930264_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!setAddress@{setAddress}}
\index{setAddress@{setAddress}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{setAddress()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a56bebae4050eebcf2a413f66718cd3b8} 
void Dynamic\+Micro\+Op\+::set\+Address (\begin{DoxyParamCaption}\item[{const \textbf{ Memory\+::\+Access} \&}]{load\+Access}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 141} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.

\index{DynamicMicroOp@{DynamicMicroOp}!setBranchMispredicted@{setBranchMispredicted}}
\index{setBranchMispredicted@{setBranchMispredicted}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{setBranchMispredicted()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a3590522667e25d7db9ee1d3f11982267} 
void Dynamic\+Micro\+Op\+::set\+Branch\+Mispredicted (\begin{DoxyParamCaption}\item[{bool}]{mispredicted}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 117} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.

\index{DynamicMicroOp@{DynamicMicroOp}!setBranchTaken@{setBranchTaken}}
\index{setBranchTaken@{setBranchTaken}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{setBranchTaken()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_ae79784a6cda27502e77b7440a69af688} 
void Dynamic\+Micro\+Op\+::set\+Branch\+Taken (\begin{DoxyParamCaption}\item[{bool}]{\+\_\+branch\+\_\+taken}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 115} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ branch\+Taken}, \textbf{ Micro\+Op\+::is\+Branch()}, \textbf{ LOG\+\_\+\+ASSERT\+\_\+\+ERROR}, and \textbf{ m\+\_\+uop}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=315pt]{classDynamicMicroOp_ae79784a6cda27502e77b7440a69af688_cgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!setBranchTarget@{setBranchTarget}}
\index{setBranchTarget@{setBranchTarget}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{setBranchTarget()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a06182c802257fcad1cf05a54223c59a4} 
void Dynamic\+Micro\+Op\+::set\+Branch\+Target (\begin{DoxyParamCaption}\item[{\textbf{ Int\+Ptr}}]{address}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 119} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ address}.

\index{DynamicMicroOp@{DynamicMicroOp}!setDCacheHitWhere@{setDCacheHitWhere}}
\index{setDCacheHitWhere@{setDCacheHitWhere}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{setDCacheHitWhere()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a7c6c643b9b3054ba51e8dbd9e237a4a9} 
void Dynamic\+Micro\+Op\+::set\+DCache\+Hit\+Where (\begin{DoxyParamCaption}\item[{\textbf{ Hit\+Where\+::where\+\_\+t}}]{\+\_\+hit\+Where}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 132} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ d\+Cache\+Hit\+Where}.



Referenced by \textbf{ Rob\+Smt\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Timer\+::issue\+Instruction()}, and \textbf{ Interval\+Timer\+::issue\+Mem\+Op()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a7c6c643b9b3054ba51e8dbd9e237a4a9_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!setExecLatency@{setExecLatency}}
\index{setExecLatency@{setExecLatency}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{setExecLatency()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a57e0232d61bc713c78d4007c3f4c8f8f} 
void Dynamic\+Micro\+Op\+::set\+Exec\+Latency (\begin{DoxyParamCaption}\item[{\textbf{ uint32\+\_\+t}}]{latency}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 126} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ Micro\+Op\+Performance\+Model\+::handle\+Instruction()}, \textbf{ Rob\+Smt\+Timer\+::issue\+Instruction()}, \textbf{ Rob\+Timer\+::issue\+Instruction()}, and \textbf{ Interval\+Timer\+::issue\+Mem\+Op()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a57e0232d61bc713c78d4007c3f4c8f8f_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!setFirst@{setFirst}}
\index{setFirst@{setFirst}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{setFirst()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_aeb3b6d8e96bdbf89a0636b588a8838a8} 
void Dynamic\+Micro\+Op\+::set\+First (\begin{DoxyParamCaption}\item[{bool}]{\+\_\+first}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 108} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ first}.

\index{DynamicMicroOp@{DynamicMicroOp}!setForceLongLatencyLoad@{setForceLongLatencyLoad}}
\index{setForceLongLatencyLoad@{setForceLongLatencyLoad}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{setForceLongLatencyLoad()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a0dc3b66764b069c47f2017b471213cbc} 
void Dynamic\+Micro\+Op\+::set\+Force\+Long\+Latency\+Load (\begin{DoxyParamCaption}\item[{bool}]{force\+LLL}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 144} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ m\+\_\+force\+Long\+Latency\+Load}.



Referenced by \textbf{ Micro\+Op\+Performance\+Model\+::handle\+Instruction()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=348pt]{classDynamicMicroOp_a0dc3b66764b069c47f2017b471213cbc_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!setICacheHitWhere@{setICacheHitWhere}}
\index{setICacheHitWhere@{setICacheHitWhere}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{setICacheHitWhere()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_ae775eb3d6f804d1a5773099e398481f8} 
void Dynamic\+Micro\+Op\+::set\+ICache\+Hit\+Where (\begin{DoxyParamCaption}\item[{\textbf{ Hit\+Where\+::where\+\_\+t}}]{\+\_\+hit\+Where}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 135} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ i\+Cache\+Hit\+Where}.

\index{DynamicMicroOp@{DynamicMicroOp}!setICacheLatency@{setICacheLatency}}
\index{setICacheLatency@{setICacheLatency}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{setICacheLatency()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a5f1b4d187df61a38c72f3f98c5bd0e42} 
void Dynamic\+Micro\+Op\+::set\+ICache\+Latency (\begin{DoxyParamCaption}\item[{\textbf{ uint32\+\_\+t}}]{\+\_\+latency}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 138} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ i\+Cache\+Latency}.

\index{DynamicMicroOp@{DynamicMicroOp}!setIntraInstrDependenciesLength@{setIntraInstrDependenciesLength}}
\index{setIntraInstrDependenciesLength@{setIntraInstrDependenciesLength}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{setIntraInstrDependenciesLength()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a6255d059911ca1a8f0d4981a43732ade} 
void Dynamic\+Micro\+Op\+::set\+Intra\+Instr\+Dependencies\+Length (\begin{DoxyParamCaption}\item[{\textbf{ uint32\+\_\+t}}]{deps}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 100} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ intra\+Instruction\+Dependencies}.



Referenced by \textbf{ Micro\+Op\+Performance\+Model\+::do\+Squashing()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a6255d059911ca1a8f0d4981a43732ade_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!setLast@{setLast}}
\index{setLast@{setLast}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{setLast()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_aa92f17d0e67b1c4edea0544013e047d3} 
void Dynamic\+Micro\+Op\+::set\+Last (\begin{DoxyParamCaption}\item[{bool}]{\+\_\+last}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 111} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ last}.

\index{DynamicMicroOp@{DynamicMicroOp}!setMicroOpTypeOffset@{setMicroOpTypeOffset}}
\index{setMicroOpTypeOffset@{setMicroOpTypeOffset}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{setMicroOpTypeOffset()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a07d1920173806ae182d0ee07ff9f3b8e} 
void Dynamic\+Micro\+Op\+::set\+Micro\+Op\+Type\+Offset (\begin{DoxyParamCaption}\item[{\textbf{ uint32\+\_\+t}}]{offset}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 103} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ micro\+Op\+Type\+Offset}.



Referenced by \textbf{ Micro\+Op\+Performance\+Model\+::do\+Squashing()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_a07d1920173806ae182d0ee07ff9f3b8e_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!setSequenceNumber@{setSequenceNumber}}
\index{setSequenceNumber@{setSequenceNumber}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{setSequenceNumber()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_aab285020b1ed1f1f434a39e770a60721} 
void Dynamic\+Micro\+Op\+::set\+Sequence\+Number (\begin{DoxyParamCaption}\item[{\textbf{ uint64\+\_\+t}}]{number}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 129} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ Windows\+::add()}, \textbf{ Rob\+Smt\+Timer\+::\+Rob\+Entry\+::init()}, and \textbf{ Rob\+Timer\+::\+Rob\+Entry\+::init()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_aab285020b1ed1f1f434a39e770a60721_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!setSquashedCount@{setSquashedCount}}
\index{setSquashedCount@{setSquashedCount}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{setSquashedCount()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_ab2a232e5fc329a9769d90b72dbeecde8} 
void Dynamic\+Micro\+Op\+::set\+Squashed\+Count (\begin{DoxyParamCaption}\item[{\textbf{ uint32\+\_\+t}}]{count}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line \textbf{ 106} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



References \textbf{ squashed\+Count}.



Referenced by \textbf{ Micro\+Op\+Performance\+Model\+::do\+Squashing()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_ab2a232e5fc329a9769d90b72dbeecde8_icgraph}
\end{center}
\end{figure}
\index{DynamicMicroOp@{DynamicMicroOp}!squash@{squash}}
\index{squash@{squash}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{squash()}
{\footnotesize\ttfamily \label{classDynamicMicroOp_abf453c5507cf09634b1a1ee619b89c8a} 
void Dynamic\+Micro\+Op\+::squash (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \textbf{ Dynamic\+Micro\+Op} $\ast$ $>$ $\ast$}]{array}{ = {\ttfamily NULL}}\end{DoxyParamCaption})}



Definition at line \textbf{ 45} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+cc}.



References \textbf{ is\+Squashed()}, and \textbf{ squashed}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classDynamicMicroOp_abf453c5507cf09634b1a1ee619b89c8a_cgraph}
\end{center}
\end{figure}


\doxysubsection{Member Data Documentation}
\index{DynamicMicroOp@{DynamicMicroOp}!address@{address}}
\index{address@{address}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{address}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a055e480026ba38322527c705b24c47be} 
\textbf{ Memory\+::\+Access} Dynamic\+Micro\+Op\+::address\hspace{0.3cm}{\ttfamily [private]}}

The address is valid for UOP\+\_\+\+LOAD and UOP\+\_\+\+STORE, it contains the load or store address. 

Definition at line \textbf{ 27} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ get\+Address()}, \textbf{ get\+Load\+Access()}, \textbf{ get\+Store\+Access()}, and \textbf{ set\+Branch\+Target()}.

\index{DynamicMicroOp@{DynamicMicroOp}!branchMispredicted@{branchMispredicted}}
\index{branchMispredicted@{branchMispredicted}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{branchMispredicted}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a440ac0100cbba2f3a1678bd4a35ffe3a} 
bool Dynamic\+Micro\+Op\+::branch\+Mispredicted\hspace{0.3cm}{\ttfamily [private]}}

Is branch mispredicted ? Only for UOP\+\_\+\+EXECUTE and branches. 

Definition at line \textbf{ 49} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ Dynamic\+Micro\+Op()}, and \textbf{ is\+Branch\+Mispredicted()}.

\index{DynamicMicroOp@{DynamicMicroOp}!branchTaken@{branchTaken}}
\index{branchTaken@{branchTaken}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{branchTaken}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a7d9e3638aed278b040bbe7053f13fd17} 
bool Dynamic\+Micro\+Op\+::branch\+Taken\hspace{0.3cm}{\ttfamily [private]}}

Did a jump occur after this instruction ? 

Definition at line \textbf{ 47} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ Dynamic\+Micro\+Op()}, \textbf{ is\+Branch\+Taken()}, and \textbf{ set\+Branch\+Taken()}.

\index{DynamicMicroOp@{DynamicMicroOp}!branchTargetAddress@{branchTargetAddress}}
\index{branchTargetAddress@{branchTargetAddress}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{branchTargetAddress}
{\footnotesize\ttfamily \label{classDynamicMicroOp_adc3e5154c50fd881561c60caa0fb651f} 
\textbf{ Int\+Ptr} Dynamic\+Micro\+Op\+::branch\+Target\+Address\hspace{0.3cm}{\ttfamily [private]}}

Branch target address 

Definition at line \textbf{ 51} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ get\+Branch\+Target()}.

\index{DynamicMicroOp@{DynamicMicroOp}!dCacheHitWhere@{dCacheHitWhere}}
\index{dCacheHitWhere@{dCacheHitWhere}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{dCacheHitWhere}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a38fe187b62d901b5dafb2ab260b35e90} 
\textbf{ Hit\+Where\+::where\+\_\+t} Dynamic\+Micro\+Op\+::d\+Cache\+Hit\+Where\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \textbf{ 53} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ Dynamic\+Micro\+Op()}, \textbf{ get\+DCache\+Hit\+Where()}, and \textbf{ set\+DCache\+Hit\+Where()}.

\index{DynamicMicroOp@{DynamicMicroOp}!dependencies@{dependencies}}
\index{dependencies@{dependencies}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{dependencies}
{\footnotesize\ttfamily \label{classDynamicMicroOp_aa38287e5e666d9d340411434bbd1c93a} 
\textbf{ uint64\+\_\+t} Dynamic\+Micro\+Op\+::dependencies[\textbf{ MAXIMUM\+\_\+\+NUMBER\+\_\+\+OF\+\_\+\+DEPENDENCIES}]\hspace{0.3cm}{\ttfamily [private]}}

This array contains the dependencies. The uint64\+\_\+t stored in the array is the sequence\+Number of the dependency. 

Definition at line \textbf{ 41} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ add\+Dependency()}, \textbf{ Dynamic\+Micro\+Op()}, \textbf{ get\+Dependency()}, and \textbf{ remove\+Dependency()}.

\index{DynamicMicroOp@{DynamicMicroOp}!dependenciesLength@{dependenciesLength}}
\index{dependenciesLength@{dependenciesLength}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{dependenciesLength}
{\footnotesize\ttfamily \label{classDynamicMicroOp_ac06730595202675266ae6cd99b173bdf} 
\textbf{ uint32\+\_\+t} Dynamic\+Micro\+Op\+::dependencies\+Length\hspace{0.3cm}{\ttfamily [private]}}

This field contains the length of the dependencies array. 

Definition at line \textbf{ 39} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ add\+Dependency()}, \textbf{ Dynamic\+Micro\+Op()}, \textbf{ get\+Dependencies\+Length()}, \textbf{ get\+Dependency()}, and \textbf{ remove\+Dependency()}.

\index{DynamicMicroOp@{DynamicMicroOp}!execLatency@{execLatency}}
\index{execLatency@{execLatency}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{execLatency}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a5f72c31457f400ba26e3361cb9551f3f} 
\textbf{ uint32\+\_\+t} Dynamic\+Micro\+Op\+::exec\+Latency\hspace{0.3cm}{\ttfamily [private]}}

The latency of the instruction. 

Definition at line \textbf{ 44} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ Dynamic\+Micro\+Op()}, \textbf{ get\+Exec\+Latency()}, and \textbf{ is\+Long\+Latency\+Load()}.

\index{DynamicMicroOp@{DynamicMicroOp}!first@{first}}
\index{first@{first}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{first}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a90285c348c3c6cd1e227d044d7a88577} 
bool Dynamic\+Micro\+Op\+::first\hspace{0.3cm}{\ttfamily [private]}}

These first/last flags are needed in case of squashing, as long as squashed uop doesn\textquotesingle{}t go to rob and we can\textquotesingle{}t use first/last flags of m\+\_\+uop in such a cases. This micro\+Op is the first micro\+Op of the instruction. 

Definition at line \textbf{ 62} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ Dynamic\+Micro\+Op()}, \textbf{ is\+First()}, and \textbf{ set\+First()}.

\index{DynamicMicroOp@{DynamicMicroOp}!iCacheHitWhere@{iCacheHitWhere}}
\index{iCacheHitWhere@{iCacheHitWhere}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{iCacheHitWhere}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a937d0211ee4ec173e737b76f907c41af} 
\textbf{ Hit\+Where\+::where\+\_\+t} Dynamic\+Micro\+Op\+::i\+Cache\+Hit\+Where\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \textbf{ 54} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ Dynamic\+Micro\+Op()}, \textbf{ get\+ICache\+Hit\+Where()}, and \textbf{ set\+ICache\+Hit\+Where()}.

\index{DynamicMicroOp@{DynamicMicroOp}!iCacheLatency@{iCacheLatency}}
\index{iCacheLatency@{iCacheLatency}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{iCacheLatency}
{\footnotesize\ttfamily \label{classDynamicMicroOp_add4283d7e442fb3174e02b8ad02fcd97} 
\textbf{ uint32\+\_\+t} Dynamic\+Micro\+Op\+::i\+Cache\+Latency\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \textbf{ 55} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ Dynamic\+Micro\+Op()}, \textbf{ get\+ICache\+Latency()}, and \textbf{ set\+ICache\+Latency()}.

\index{DynamicMicroOp@{DynamicMicroOp}!intraInstructionDependencies@{intraInstructionDependencies}}
\index{intraInstructionDependencies@{intraInstructionDependencies}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{intraInstructionDependencies}
{\footnotesize\ttfamily \label{classDynamicMicroOp_ac1dcf52c17d2647e1eecb20f98b2f3e2} 
\textbf{ uint32\+\_\+t} Dynamic\+Micro\+Op\+::intra\+Instruction\+Dependencies\hspace{0.3cm}{\ttfamily [private]}}

Initially copied from \doxyref{Micro\+Op}{p.}{structMicroOp}, but can be changed by remove\+Dependency 

Definition at line \textbf{ 33} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ Dynamic\+Micro\+Op()}, \textbf{ get\+Dependency()}, \textbf{ get\+Intra\+Instr\+Dependencies\+Length()}, \textbf{ remove\+Dependency()}, and \textbf{ set\+Intra\+Instr\+Dependencies\+Length()}.

\index{DynamicMicroOp@{DynamicMicroOp}!last@{last}}
\index{last@{last}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{last}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a405866d33eb97bbdd2bd6fef24a286b9} 
bool Dynamic\+Micro\+Op\+::last\hspace{0.3cm}{\ttfamily [private]}}

This micro\+Op is the last micro\+Op of the instruction. 

Definition at line \textbf{ 64} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ Dynamic\+Micro\+Op()}, \textbf{ is\+Last()}, and \textbf{ set\+Last()}.

\index{DynamicMicroOp@{DynamicMicroOp}!m\_core\_model@{m\_core\_model}}
\index{m\_core\_model@{m\_core\_model}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{m\_core\_model}
{\footnotesize\ttfamily \label{classDynamicMicroOp_af565ac9ef7010725ea17b5bf11afb54c} 
const \textbf{ Core\+Model}$\ast$ Dynamic\+Micro\+Op\+::m\+\_\+core\+\_\+model\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \textbf{ 18} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ Dynamic\+Micro\+Op()}, and \textbf{ is\+Long\+Latency\+Load()}.

\index{DynamicMicroOp@{DynamicMicroOp}!m\_forceLongLatencyLoad@{m\_forceLongLatencyLoad}}
\index{m\_forceLongLatencyLoad@{m\_forceLongLatencyLoad}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{m\_forceLongLatencyLoad}
{\footnotesize\ttfamily \label{classDynamicMicroOp_ad903cba4ec41d8d49deeb6e4150a0e3b} 
bool Dynamic\+Micro\+Op\+::m\+\_\+force\+Long\+Latency\+Load\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \textbf{ 57} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ Dynamic\+Micro\+Op()}, \textbf{ is\+Long\+Latency\+Load()}, and \textbf{ set\+Force\+Long\+Latency\+Load()}.

\index{DynamicMicroOp@{DynamicMicroOp}!m\_period@{m\_period}}
\index{m\_period@{m\_period}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{m\_period}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a65108395b8b365b99233809feab9a2f8} 
const \textbf{ Subsecond\+Time} Dynamic\+Micro\+Op\+::m\+\_\+period\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \textbf{ 21} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ get\+Period()}.

\index{DynamicMicroOp@{DynamicMicroOp}!m\_uop@{m\_uop}}
\index{m\_uop@{m\_uop}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{m\_uop}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a2ecffe500f67783cfa82d1c53d1c6789} 
const \textbf{ Micro\+Op}$\ast$ Dynamic\+Micro\+Op\+::m\+\_\+uop\hspace{0.3cm}{\ttfamily [private]}}



Definition at line \textbf{ 17} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ Dynamic\+Micro\+Op()}, \textbf{ get\+Branch\+Target()}, \textbf{ get\+Micro\+Op()}, \textbf{ is\+Branch\+Mispredicted()}, \textbf{ is\+Branch\+Taken()}, and \textbf{ set\+Branch\+Taken()}.

\index{DynamicMicroOp@{DynamicMicroOp}!microOpTypeOffset@{microOpTypeOffset}}
\index{microOpTypeOffset@{microOpTypeOffset}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{microOpTypeOffset}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a31ec5eefca118682dd8f6d50a16614f5} 
\textbf{ uint32\+\_\+t} Dynamic\+Micro\+Op\+::micro\+Op\+Type\+Offset\hspace{0.3cm}{\ttfamily [private]}}

Initially copied from \doxyref{Micro\+Op}{p.}{structMicroOp}, but can be changed in case of squashing 

Definition at line \textbf{ 35} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ Dynamic\+Micro\+Op()}, \textbf{ get\+Dependency()}, \textbf{ get\+Micro\+Op\+Type\+Offset()}, \textbf{ remove\+Dependency()}, and \textbf{ set\+Micro\+Op\+Type\+Offset()}.

\index{DynamicMicroOp@{DynamicMicroOp}!sequenceNumber@{sequenceNumber}}
\index{sequenceNumber@{sequenceNumber}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{sequenceNumber}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a26fe4526d9778ae1d17e5a641dcf5f2b} 
\textbf{ uint64\+\_\+t} Dynamic\+Micro\+Op\+::sequence\+Number\hspace{0.3cm}{\ttfamily [private]}}

The sequence number of the micro\+Operation. Unique (per thread) ! 

Definition at line \textbf{ 24} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ add\+Dependency()}, \textbf{ Dynamic\+Micro\+Op()}, \textbf{ get\+Dependency()}, \textbf{ get\+Sequence\+Number()}, and \textbf{ remove\+Dependency()}.

\index{DynamicMicroOp@{DynamicMicroOp}!squashed@{squashed}}
\index{squashed@{squashed}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{squashed}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a02cc72b479dfdef24efd23d7058c542e} 
bool Dynamic\+Micro\+Op\+::squashed\hspace{0.3cm}{\ttfamily [private]}}

The microop has been squashed 

Definition at line \textbf{ 30} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ Dynamic\+Micro\+Op()}, \textbf{ is\+Squashed()}, and \textbf{ squash()}.

\index{DynamicMicroOp@{DynamicMicroOp}!squashedCount@{squashedCount}}
\index{squashedCount@{squashedCount}!DynamicMicroOp@{DynamicMicroOp}}
\doxysubsubsection{squashedCount}
{\footnotesize\ttfamily \label{classDynamicMicroOp_a3a566e31b5a13cc44b62738006b20d15} 
\textbf{ uint32\+\_\+t} Dynamic\+Micro\+Op\+::squashed\+Count\hspace{0.3cm}{\ttfamily [private]}}

Used in do\+Squashing. Contains number of squashed preceding uops of the instruction 

Definition at line \textbf{ 37} of file \textbf{ dynamic\+\_\+micro\+\_\+op.\+h}.



Referenced by \textbf{ Dynamic\+Micro\+Op()}, \textbf{ get\+Squashed\+Count()}, and \textbf{ set\+Squashed\+Count()}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
common/performance\+\_\+model/performance\+\_\+models/micro\+\_\+op/\textbf{ dynamic\+\_\+micro\+\_\+op.\+h}\item 
common/performance\+\_\+model/performance\+\_\+models/micro\+\_\+op/\textbf{ dynamic\+\_\+micro\+\_\+op.\+cc}\end{DoxyCompactItemize}
