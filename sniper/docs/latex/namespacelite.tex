\doxysection{lite Namespace Reference}
\label{namespacelite}\index{lite@{lite}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ pthread\+\_\+functions\+\_\+t}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \textbf{ handle\+Syscall} (THREADID thread\+Index, CONTEXT $\ast$ctx)
\item 
void \textbf{ syscall\+Enter\+Run\+Model} (THREADID thread\+Index, CONTEXT $\ast$ctx, SYSCALL\+\_\+\+STANDARD syscall\+\_\+standard, void $\ast$v)
\item 
void \textbf{ syscall\+Exit\+Run\+Model} (THREADID thread\+Index, CONTEXT $\ast$ctx, SYSCALL\+\_\+\+STANDARD syscall\+\_\+standard, void $\ast$v)
\item 
bool \textbf{ intercept\+Signal} (THREADID thread\+Index, INT32 signal, CONTEXT $\ast$ctx, BOOL has\+Handler, const EXCEPTION\+\_\+\+INFO $\ast$p\+Except\+Info, void $\ast$v)
\item 
void \textbf{ add\+Memory\+Modeling} (TRACE trace, INS ins, \textbf{ Inst\+Mode\+::inst\+\_\+mode\+\_\+t} inst\+\_\+mode)
\item 
void \textbf{ handle\+Memory\+Read} (THREADID thread\+\_\+id, BOOL executing, ADDRINT eip, bool is\+\_\+atomic\+\_\+update, \textbf{ Int\+Ptr} read\+\_\+address, \textbf{ UInt32} read\+\_\+data\+\_\+size)
\item 
void \textbf{ handle\+Memory\+Read\+Detailed} (THREADID thread\+\_\+id, BOOL executing, ADDRINT eip, bool is\+\_\+atomic\+\_\+update, \textbf{ Int\+Ptr} read\+\_\+address, \textbf{ UInt32} read\+\_\+data\+\_\+size)
\item 
void \textbf{ handle\+Memory\+Read\+Detailed\+Issue} (THREADID thread\+\_\+id, BOOL executing, ADDRINT eip, bool is\+\_\+atomic\+\_\+update, \textbf{ Int\+Ptr} read\+\_\+address, \textbf{ UInt32} read\+\_\+data\+\_\+size)
\item 
ADDRINT \textbf{ handle\+Memory\+Read\+Faultinjection\+Nondetailed} (bool is\+\_\+atomic\+\_\+update, ADDRINT read\+\_\+address, ADDRINT $\ast$save\+\_\+ea)
\item 
ADDRINT \textbf{ handle\+Memory\+Read\+Faultinjection} (THREADID thread\+\_\+id, BOOL executing, ADDRINT eip, bool is\+\_\+atomic\+\_\+update, ADDRINT read\+\_\+address, \textbf{ UInt32} read\+\_\+data\+\_\+size, \textbf{ UInt32} op\+\_\+num, ADDRINT $\ast$save\+\_\+ea)
\item 
void \textbf{ complete\+Memory\+Write} (bool is\+\_\+atomic\+\_\+update, ADDRINT write\+\_\+address, ADDRINT scratch, UINT32 write\+\_\+size)
\item 
void \textbf{ handle\+Memory\+Write} (THREADID thread\+\_\+id, BOOL executing, ADDRINT eip, bool is\+\_\+atomic\+\_\+update, \textbf{ Int\+Ptr} write\+\_\+address, \textbf{ UInt32} write\+\_\+data\+\_\+size)
\item 
void \textbf{ handle\+Memory\+Write\+Detailed} (THREADID thread\+\_\+id, BOOL executing, ADDRINT eip, bool is\+\_\+atomic\+\_\+update, \textbf{ Int\+Ptr} write\+\_\+address, \textbf{ UInt32} write\+\_\+data\+\_\+size)
\item 
void \textbf{ handle\+Memory\+Write\+Detailed\+Issue} (THREADID thread\+\_\+id, BOOL executing, ADDRINT eip, bool is\+\_\+atomic\+\_\+update, \textbf{ Int\+Ptr} write\+\_\+address, \textbf{ UInt32} write\+\_\+data\+\_\+size)
\item 
void \textbf{ handle\+Memory\+Write\+Faultinjection} (THREADID thread\+\_\+id, BOOL executing, ADDRINT eip, bool is\+\_\+atomic\+\_\+update, \textbf{ Int\+Ptr} write\+\_\+address, \textbf{ UInt32} write\+\_\+data\+\_\+size)
\item 
void \textbf{ print\+Stack\+Trace} (THREADID threadid, char $\ast$function, BOOL enter)
\item 
void \textbf{ routine\+Start\+Callback} (RTN rtn, INS ins)
\item 
void \textbf{ routine\+Callback} (RTN rtn, void $\ast$v)
\item 
AFUNPTR \textbf{ get\+Funptr} (CONTEXT $\ast$context, string func\+\_\+name)
\item 
\textbf{ Int\+Ptr} \textbf{ null\+Function} ()
\item 
void \textbf{ pthread\+Before} (THREADID thread\+\_\+id)
\item 
void \textbf{ pthread\+After} (THREADID thread\+\_\+id, ADDRINT type\+\_\+id, ADDRINT retval)
\item 
void \textbf{ malloc\+Before} (THREADID thread\+\_\+id, ADDRINT eip, ADDRINT size)
\item 
void \textbf{ malloc\+After} (THREADID thread\+\_\+id, ADDRINT address)
\item 
void \textbf{ free\+Before} (THREADID thread\+\_\+id, ADDRINT eip, ADDRINT address)
\item 
\textbf{ Int\+Ptr} \textbf{ emu\+Get\+Nprocs} ()
\item 
\textbf{ Int\+Ptr} \textbf{ emu\+Get\+CPU} (THREADID thread\+\_\+id)
\item 
\textbf{ Int\+Ptr} \textbf{ emu\+Clock\+Gettime} (THREADID thread\+\_\+id, clockid\+\_\+t clk\+\_\+id, struct timespec $\ast$tp)
\item 
\textbf{ Int\+Ptr} \textbf{ emu\+Gettimeofday} (THREADID thread\+\_\+id, struct timeval $\ast$tv, struct timezone $\ast$tz)
\item 
void \textbf{ emu\+Kmp\+Reap\+Monitor} (THREADID thread\+Index, CONTEXT $\ast$ctxt)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\textbf{ Lock} \textbf{ g\+\_\+atomic\+\_\+lock}
\item 
char \textbf{ g\+\_\+zeros} [1024] = \{ 0 \}
\item 
std\+::unordered\+\_\+map$<$ \textbf{ core\+\_\+id\+\_\+t}, \textbf{ Subsecond\+Time} $>$ \textbf{ pthread\+\_\+t\+\_\+start}
\item 
AFUNPTR \textbf{ ptr\+\_\+exit} = NULL
\item 
struct \textbf{ lite\+::pthread\+\_\+functions\+\_\+t} \textbf{ pthread\+\_\+functions} [$\,$]
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\index{lite@{lite}!addMemoryModeling@{addMemoryModeling}}
\index{addMemoryModeling@{addMemoryModeling}!lite@{lite}}
\doxysubsubsection{addMemoryModeling()}
{\footnotesize\ttfamily \label{namespacelite_ac3c511da4ecd2a68f3a5f1c1d81c45bd} 
void lite\+::add\+Memory\+Modeling (\begin{DoxyParamCaption}\item[{TRACE}]{trace}{, }\item[{INS}]{ins}{, }\item[{\textbf{ Inst\+Mode\+::inst\+\_\+mode\+\_\+t}}]{inst\+\_\+mode}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 20} of file \textbf{ memory\+\_\+modeling.\+cc}.



References \textbf{ complete\+Memory\+Write()}, \textbf{ g\+\_\+toolregs}, \textbf{ handle\+Memory\+Read()}, \textbf{ handle\+Memory\+Read\+Detailed()}, \textbf{ handle\+Memory\+Read\+Detailed\+Issue()}, \textbf{ handle\+Memory\+Read\+Faultinjection()}, \textbf{ handle\+Memory\+Read\+Faultinjection\+Nondetailed()}, \textbf{ handle\+Memory\+Write()}, \textbf{ handle\+Memory\+Write\+Detailed()}, \textbf{ handle\+Memory\+Write\+Detailed\+Issue()}, \textbf{ handle\+Memory\+Write\+Faultinjection()}, \textbf{ INSTR\+\_\+\+IF\+\_\+\+CACHEONLY}, \textbf{ INSTR\+\_\+\+IF\+\_\+\+DETAILED}, \textbf{ INSTR\+\_\+\+IF\+\_\+\+FASTFORWARD}, \textbf{ INSTRUMENT}, \textbf{ LOG\+\_\+\+ASSERT\+\_\+\+ERROR}, \textbf{ Thread\+Local\+Storage\+::\+NUM\+\_\+\+SCRATCHPADS}, \textbf{ TOOLREG\+\_\+\+EA0}, \textbf{ TOOLREG\+\_\+\+MEM0}, and \textbf{ TOOLREG\+\_\+\+NUM\+\_\+\+MEM}.



Referenced by \textbf{ Instruction\+Modeling\+::add\+Instruction\+Modeling()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_ac3c511da4ecd2a68f3a5f1c1d81c45bd_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_ac3c511da4ecd2a68f3a5f1c1d81c45bd_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!completeMemoryWrite@{completeMemoryWrite}}
\index{completeMemoryWrite@{completeMemoryWrite}!lite@{lite}}
\doxysubsubsection{completeMemoryWrite()}
{\footnotesize\ttfamily \label{namespacelite_ad2bbe12382f568e7ce80b05f11cac846} 
void lite\+::complete\+Memory\+Write (\begin{DoxyParamCaption}\item[{bool}]{is\+\_\+atomic\+\_\+update}{, }\item[{ADDRINT}]{write\+\_\+address}{, }\item[{ADDRINT}]{scratch}{, }\item[{UINT32}]{write\+\_\+size}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 284} of file \textbf{ memory\+\_\+modeling.\+cc}.



References \textbf{ g\+\_\+atomic\+\_\+lock}, and \textbf{ TLock$<$ T\+\_\+\+Lock\+Creator $>$\+::release()}.



Referenced by \textbf{ add\+Memory\+Modeling()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_ad2bbe12382f568e7ce80b05f11cac846_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_ad2bbe12382f568e7ce80b05f11cac846_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!emuClockGettime@{emuClockGettime}}
\index{emuClockGettime@{emuClockGettime}!lite@{lite}}
\doxysubsubsection{emuClockGettime()}
{\footnotesize\ttfamily \label{namespacelite_a7feb391820383e311fc22b9f1bab6d9f} 
\textbf{ Int\+Ptr} lite\+::emu\+Clock\+Gettime (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+\_\+id}{, }\item[{clockid\+\_\+t}]{clk\+\_\+id}{, }\item[{struct timespec $\ast$}]{tp}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 391} of file \textbf{ routine\+\_\+replace.\+cc}.



References \textbf{ Performance\+Model\+::get\+Elapsed\+Time()}, \textbf{ Subsecond\+Time\+::get\+NS()}, \textbf{ Core\+::get\+Performance\+Model()}, and \textbf{ local\+Store}.



Referenced by \textbf{ routine\+Callback()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_a7feb391820383e311fc22b9f1bab6d9f_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_a7feb391820383e311fc22b9f1bab6d9f_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!emuGetCPU@{emuGetCPU}}
\index{emuGetCPU@{emuGetCPU}!lite@{lite}}
\doxysubsubsection{emuGetCPU()}
{\footnotesize\ttfamily \label{namespacelite_ae846d367ed7ea5a541559a79ac74040a} 
\textbf{ Int\+Ptr} lite\+::emu\+Get\+CPU (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+\_\+id}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 384} of file \textbf{ routine\+\_\+replace.\+cc}.



References \textbf{ Core\+::get\+Id()}, and \textbf{ local\+Store}.



Referenced by \textbf{ routine\+Callback()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=231pt]{namespacelite_ae846d367ed7ea5a541559a79ac74040a_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=342pt]{namespacelite_ae846d367ed7ea5a541559a79ac74040a_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!emuGetNprocs@{emuGetNprocs}}
\index{emuGetNprocs@{emuGetNprocs}!lite@{lite}}
\doxysubsubsection{emuGetNprocs()}
{\footnotesize\ttfamily \label{namespacelite_adfe9bbb756e61b8c45e1cd5008ce5791} 
\textbf{ Int\+Ptr} lite\+::emu\+Get\+Nprocs (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 377} of file \textbf{ routine\+\_\+replace.\+cc}.



Referenced by \textbf{ routine\+Callback()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_adfe9bbb756e61b8c45e1cd5008ce5791_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!emuGettimeofday@{emuGettimeofday}}
\index{emuGettimeofday@{emuGettimeofday}!lite@{lite}}
\doxysubsubsection{emuGettimeofday()}
{\footnotesize\ttfamily \label{namespacelite_a4a96d0896de2e5a1ac18e13f888424c9} 
\textbf{ Int\+Ptr} lite\+::emu\+Gettimeofday (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+\_\+id}{, }\item[{struct timeval $\ast$}]{tv}{, }\item[{struct timezone $\ast$}]{tz}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 415} of file \textbf{ routine\+\_\+replace.\+cc}.



References \textbf{ Performance\+Model\+::get\+Elapsed\+Time()}, \textbf{ Subsecond\+Time\+::get\+NS()}, \textbf{ Core\+::get\+Performance\+Model()}, \textbf{ local\+Store}, \textbf{ LOG\+\_\+\+ASSERT\+\_\+\+ERROR}, and \textbf{ LOG\+\_\+\+ASSERT\+\_\+\+WARNING\+\_\+\+ONCE}.



Referenced by \textbf{ routine\+Callback()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_a4a96d0896de2e5a1ac18e13f888424c9_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_a4a96d0896de2e5a1ac18e13f888424c9_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!emuKmpReapMonitor@{emuKmpReapMonitor}}
\index{emuKmpReapMonitor@{emuKmpReapMonitor}!lite@{lite}}
\doxysubsubsection{emuKmpReapMonitor()}
{\footnotesize\ttfamily \label{namespacelite_ada03f987d3da820c1b246dfbac3f37ae} 
void lite\+::emu\+Kmp\+Reap\+Monitor (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+Index}{, }\item[{CONTEXT $\ast$}]{ctxt}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 431} of file \textbf{ routine\+\_\+replace.\+cc}.



References \textbf{ ptr\+\_\+exit}.



Referenced by \textbf{ routine\+Start\+Callback()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_ada03f987d3da820c1b246dfbac3f37ae_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!freeBefore@{freeBefore}}
\index{freeBefore@{freeBefore}!lite@{lite}}
\doxysubsubsection{freeBefore()}
{\footnotesize\ttfamily \label{namespacelite_a7998b0a42a4d3b642382e7a2254e733a} 
void lite\+::free\+Before (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+\_\+id}{, }\item[{ADDRINT}]{eip}{, }\item[{ADDRINT}]{address}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 372} of file \textbf{ routine\+\_\+replace.\+cc}.



References \textbf{ local\+Store}.



Referenced by \textbf{ routine\+Callback()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=331pt]{namespacelite_a7998b0a42a4d3b642382e7a2254e733a_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!getFunptr@{getFunptr}}
\index{getFunptr@{getFunptr}!lite@{lite}}
\doxysubsubsection{getFunptr()}
{\footnotesize\ttfamily \label{namespacelite_a7164aef92219dae46c21e534720f1933} 
AFUNPTR lite\+::get\+Funptr (\begin{DoxyParamCaption}\item[{CONTEXT $\ast$}]{context}{, }\item[{string}]{func\+\_\+name}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 318} of file \textbf{ routine\+\_\+replace.\+cc}.

\index{lite@{lite}!handleMemoryRead@{handleMemoryRead}}
\index{handleMemoryRead@{handleMemoryRead}!lite@{lite}}
\doxysubsubsection{handleMemoryRead()}
{\footnotesize\ttfamily \label{namespacelite_ace26a1209652932499df988d3536a15d} 
void lite\+::handle\+Memory\+Read (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+\_\+id}{, }\item[{BOOL}]{executing}{, }\item[{ADDRINT}]{eip}{, }\item[{bool}]{is\+\_\+atomic\+\_\+update}{, }\item[{\textbf{ Int\+Ptr}}]{read\+\_\+address}{, }\item[{\textbf{ UInt32}}]{read\+\_\+data\+\_\+size}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 179} of file \textbf{ memory\+\_\+modeling.\+cc}.



References \textbf{ Core\+::access\+Memory\+Fast()}, \textbf{ local\+Store}, and \textbf{ Core\+::\+READ}.



Referenced by \textbf{ add\+Memory\+Modeling()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_ace26a1209652932499df988d3536a15d_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_ace26a1209652932499df988d3536a15d_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!handleMemoryReadDetailed@{handleMemoryReadDetailed}}
\index{handleMemoryReadDetailed@{handleMemoryReadDetailed}!lite@{lite}}
\doxysubsubsection{handleMemoryReadDetailed()}
{\footnotesize\ttfamily \label{namespacelite_a7014fa1d6b2ce2f0ce049e61f43d2626} 
void lite\+::handle\+Memory\+Read\+Detailed (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+\_\+id}{, }\item[{BOOL}]{executing}{, }\item[{ADDRINT}]{eip}{, }\item[{bool}]{is\+\_\+atomic\+\_\+update}{, }\item[{\textbf{ Int\+Ptr}}]{read\+\_\+address}{, }\item[{\textbf{ UInt32}}]{read\+\_\+data\+\_\+size}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 187} of file \textbf{ memory\+\_\+modeling.\+cc}.



References \textbf{ local\+Store}, \textbf{ Operand\+::\+READ}, \textbf{ Hit\+Where\+::\+UNKNOWN}, and \textbf{ Subsecond\+Time\+::\+Zero()}.



Referenced by \textbf{ add\+Memory\+Modeling()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_a7014fa1d6b2ce2f0ce049e61f43d2626_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_a7014fa1d6b2ce2f0ce049e61f43d2626_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!handleMemoryReadDetailedIssue@{handleMemoryReadDetailedIssue}}
\index{handleMemoryReadDetailedIssue@{handleMemoryReadDetailedIssue}!lite@{lite}}
\doxysubsubsection{handleMemoryReadDetailedIssue()}
{\footnotesize\ttfamily \label{namespacelite_afd84eee2265583df2dd27f549cd4aa92} 
void lite\+::handle\+Memory\+Read\+Detailed\+Issue (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+\_\+id}{, }\item[{BOOL}]{executing}{, }\item[{ADDRINT}]{eip}{, }\item[{bool}]{is\+\_\+atomic\+\_\+update}{, }\item[{\textbf{ Int\+Ptr}}]{read\+\_\+address}{, }\item[{\textbf{ UInt32}}]{read\+\_\+data\+\_\+size}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 194} of file \textbf{ memory\+\_\+modeling.\+cc}.



References \textbf{ Core\+::access\+Memory()}, \textbf{ Memory\+Result\+::hit\+\_\+where}, \textbf{ Memory\+Result\+::latency}, \textbf{ local\+Store}, \textbf{ Core\+::\+LOCK}, \textbf{ make\+Memory\+Result()}, \textbf{ Core\+::\+MEM\+\_\+\+MODELED\+\_\+\+COUNT}, \textbf{ Core\+::\+MEM\+\_\+\+MODELED\+\_\+\+RETURN}, \textbf{ Core\+::\+NONE}, \textbf{ Hit\+Where\+::\+PREDICATE\+\_\+\+FALSE}, \textbf{ Core\+::\+READ}, \textbf{ Operand\+::\+READ}, \textbf{ Core\+::\+READ\+\_\+\+EX}, and \textbf{ Subsecond\+Time\+::\+Zero()}.



Referenced by \textbf{ add\+Memory\+Modeling()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_afd84eee2265583df2dd27f549cd4aa92_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_afd84eee2265583df2dd27f549cd4aa92_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!handleMemoryReadFaultinjection@{handleMemoryReadFaultinjection}}
\index{handleMemoryReadFaultinjection@{handleMemoryReadFaultinjection}!lite@{lite}}
\doxysubsubsection{handleMemoryReadFaultinjection()}
{\footnotesize\ttfamily \label{namespacelite_a01f29cb4c16594f8458139bda8b993bd} 
ADDRINT lite\+::handle\+Memory\+Read\+Faultinjection (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+\_\+id}{, }\item[{BOOL}]{executing}{, }\item[{ADDRINT}]{eip}{, }\item[{bool}]{is\+\_\+atomic\+\_\+update}{, }\item[{ADDRINT}]{read\+\_\+address}{, }\item[{\textbf{ UInt32}}]{read\+\_\+data\+\_\+size}{, }\item[{\textbf{ UInt32}}]{op\+\_\+num}{, }\item[{ADDRINT $\ast$}]{save\+\_\+ea}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 233} of file \textbf{ memory\+\_\+modeling.\+cc}.



References \textbf{ Core\+::access\+Memory()}, \textbf{ TLock$<$ T\+\_\+\+Lock\+Creator $>$\+::acquire()}, \textbf{ g\+\_\+atomic\+\_\+lock}, \textbf{ Memory\+Result\+::hit\+\_\+where}, \textbf{ Memory\+Result\+::latency}, \textbf{ local\+Store}, \textbf{ Subsecond\+Time\+::\+Max\+Time()}, \textbf{ Core\+::\+MEM\+\_\+\+MODELED\+\_\+\+COUNT}, \textbf{ Core\+::\+MEM\+\_\+\+MODELED\+\_\+\+RETURN}, \textbf{ Core\+::\+NONE}, \textbf{ Hit\+Where\+::\+PREDICATE\+\_\+\+FALSE}, \textbf{ Core\+::\+READ}, \textbf{ Operand\+::\+READ}, \textbf{ Core\+::\+READ\+\_\+\+EX}, and \textbf{ Subsecond\+Time\+::\+Zero()}.



Referenced by \textbf{ add\+Memory\+Modeling()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_a01f29cb4c16594f8458139bda8b993bd_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_a01f29cb4c16594f8458139bda8b993bd_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!handleMemoryReadFaultinjectionNondetailed@{handleMemoryReadFaultinjectionNondetailed}}
\index{handleMemoryReadFaultinjectionNondetailed@{handleMemoryReadFaultinjectionNondetailed}!lite@{lite}}
\doxysubsubsection{handleMemoryReadFaultinjectionNondetailed()}
{\footnotesize\ttfamily \label{namespacelite_af6b0f15dd603800b23dd20d8c64e4e47} 
ADDRINT lite\+::handle\+Memory\+Read\+Faultinjection\+Nondetailed (\begin{DoxyParamCaption}\item[{bool}]{is\+\_\+atomic\+\_\+update}{, }\item[{ADDRINT}]{read\+\_\+address}{, }\item[{ADDRINT $\ast$}]{save\+\_\+ea}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 223} of file \textbf{ memory\+\_\+modeling.\+cc}.



References \textbf{ TLock$<$ T\+\_\+\+Lock\+Creator $>$\+::acquire()}, and \textbf{ g\+\_\+atomic\+\_\+lock}.



Referenced by \textbf{ add\+Memory\+Modeling()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_af6b0f15dd603800b23dd20d8c64e4e47_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_af6b0f15dd603800b23dd20d8c64e4e47_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!handleMemoryWrite@{handleMemoryWrite}}
\index{handleMemoryWrite@{handleMemoryWrite}!lite@{lite}}
\doxysubsubsection{handleMemoryWrite()}
{\footnotesize\ttfamily \label{namespacelite_abc646937c77dedb79e151d309fe4e860} 
void lite\+::handle\+Memory\+Write (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+\_\+id}{, }\item[{BOOL}]{executing}{, }\item[{ADDRINT}]{eip}{, }\item[{bool}]{is\+\_\+atomic\+\_\+update}{, }\item[{\textbf{ Int\+Ptr}}]{write\+\_\+address}{, }\item[{\textbf{ UInt32}}]{write\+\_\+data\+\_\+size}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 292} of file \textbf{ memory\+\_\+modeling.\+cc}.



References \textbf{ Core\+::access\+Memory\+Fast()}, \textbf{ local\+Store}, \textbf{ Core\+::log\+Memory\+Hit()}, \textbf{ Core\+::\+MEM\+\_\+\+MODELED\+\_\+\+COUNT}, and \textbf{ Core\+::\+WRITE}.



Referenced by \textbf{ add\+Memory\+Modeling()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_abc646937c77dedb79e151d309fe4e860_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_abc646937c77dedb79e151d309fe4e860_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!handleMemoryWriteDetailed@{handleMemoryWriteDetailed}}
\index{handleMemoryWriteDetailed@{handleMemoryWriteDetailed}!lite@{lite}}
\doxysubsubsection{handleMemoryWriteDetailed()}
{\footnotesize\ttfamily \label{namespacelite_a45ff1a3feb59ec00194d089f8c7f7ff0} 
void lite\+::handle\+Memory\+Write\+Detailed (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+\_\+id}{, }\item[{BOOL}]{executing}{, }\item[{ADDRINT}]{eip}{, }\item[{bool}]{is\+\_\+atomic\+\_\+update}{, }\item[{\textbf{ Int\+Ptr}}]{write\+\_\+address}{, }\item[{\textbf{ UInt32}}]{write\+\_\+data\+\_\+size}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 304} of file \textbf{ memory\+\_\+modeling.\+cc}.



References \textbf{ Hit\+Where\+::\+L1\+\_\+\+OWN}, \textbf{ local\+Store}, \textbf{ Core\+::log\+Memory\+Hit()}, \textbf{ Core\+::\+MEM\+\_\+\+MODELED\+\_\+\+RETURN}, \textbf{ Hit\+Where\+::\+UNKNOWN}, \textbf{ Core\+::\+WRITE}, \textbf{ Operand\+::\+WRITE}, and \textbf{ Subsecond\+Time\+::\+Zero()}.



Referenced by \textbf{ add\+Memory\+Modeling()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_a45ff1a3feb59ec00194d089f8c7f7ff0_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_a45ff1a3feb59ec00194d089f8c7f7ff0_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!handleMemoryWriteDetailedIssue@{handleMemoryWriteDetailedIssue}}
\index{handleMemoryWriteDetailedIssue@{handleMemoryWriteDetailedIssue}!lite@{lite}}
\doxysubsubsection{handleMemoryWriteDetailedIssue()}
{\footnotesize\ttfamily \label{namespacelite_a5fd9374a027fed6f1be65385084e77c0} 
void lite\+::handle\+Memory\+Write\+Detailed\+Issue (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+\_\+id}{, }\item[{BOOL}]{executing}{, }\item[{ADDRINT}]{eip}{, }\item[{bool}]{is\+\_\+atomic\+\_\+update}{, }\item[{\textbf{ Int\+Ptr}}]{write\+\_\+address}{, }\item[{\textbf{ UInt32}}]{write\+\_\+data\+\_\+size}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 327} of file \textbf{ memory\+\_\+modeling.\+cc}.



References \textbf{ Core\+::access\+Memory()}, \textbf{ Memory\+Result\+::hit\+\_\+where}, \textbf{ Memory\+Result\+::latency}, \textbf{ local\+Store}, \textbf{ make\+Memory\+Result()}, \textbf{ Core\+::\+MEM\+\_\+\+MODELED\+\_\+\+COUNT}, \textbf{ Core\+::\+MEM\+\_\+\+MODELED\+\_\+\+RETURN}, \textbf{ Core\+::\+NONE}, \textbf{ Hit\+Where\+::\+PREDICATE\+\_\+\+FALSE}, \textbf{ Core\+::\+UNLOCK}, \textbf{ Core\+::\+WRITE}, \textbf{ Operand\+::\+WRITE}, and \textbf{ Subsecond\+Time\+::\+Zero()}.



Referenced by \textbf{ add\+Memory\+Modeling()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_a5fd9374a027fed6f1be65385084e77c0_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_a5fd9374a027fed6f1be65385084e77c0_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!handleMemoryWriteFaultinjection@{handleMemoryWriteFaultinjection}}
\index{handleMemoryWriteFaultinjection@{handleMemoryWriteFaultinjection}!lite@{lite}}
\doxysubsubsection{handleMemoryWriteFaultinjection()}
{\footnotesize\ttfamily \label{namespacelite_ab74604f8931c7a57b266bf457e9ca6b0} 
void lite\+::handle\+Memory\+Write\+Faultinjection (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+\_\+id}{, }\item[{BOOL}]{executing}{, }\item[{ADDRINT}]{eip}{, }\item[{bool}]{is\+\_\+atomic\+\_\+update}{, }\item[{\textbf{ Int\+Ptr}}]{write\+\_\+address}{, }\item[{\textbf{ UInt32}}]{write\+\_\+data\+\_\+size}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 357} of file \textbf{ memory\+\_\+modeling.\+cc}.



References \textbf{ Core\+::access\+Memory()}, \textbf{ g\+\_\+zeros}, \textbf{ Memory\+Result\+::hit\+\_\+where}, \textbf{ Hit\+Where\+::\+L1\+\_\+\+OWN}, \textbf{ Memory\+Result\+::latency}, \textbf{ local\+Store}, \textbf{ Core\+::log\+Memory\+Hit()}, \textbf{ Subsecond\+Time\+::\+Max\+Time()}, \textbf{ Core\+::\+MEM\+\_\+\+MODELED\+\_\+\+COUNT}, \textbf{ Core\+::\+MEM\+\_\+\+MODELED\+\_\+\+NONE}, \textbf{ Core\+::\+MEM\+\_\+\+MODELED\+\_\+\+RETURN}, \textbf{ Core\+::\+NONE}, \textbf{ Hit\+Where\+::\+PREDICATE\+\_\+\+FALSE}, \textbf{ Core\+::\+WRITE}, \textbf{ Operand\+::\+WRITE}, and \textbf{ Subsecond\+Time\+::\+Zero()}.



Referenced by \textbf{ add\+Memory\+Modeling()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_ab74604f8931c7a57b266bf457e9ca6b0_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_ab74604f8931c7a57b266bf457e9ca6b0_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!handleSyscall@{handleSyscall}}
\index{handleSyscall@{handleSyscall}!lite@{lite}}
\doxysubsubsection{handleSyscall()}
{\footnotesize\ttfamily \label{namespacelite_a067e6ebee2a1d430c96c627ddf6a39dd} 
void lite\+::handle\+Syscall (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+Index}{, }\item[{CONTEXT $\ast$}]{ctx}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 17} of file \textbf{ handle\+\_\+syscalls.\+cc}.



References \textbf{ Syscall\+Mdl\+::syscall\+\_\+args\+\_\+t\+::arg0}, \textbf{ Syscall\+Mdl\+::syscall\+\_\+args\+\_\+t\+::arg1}, \textbf{ Syscall\+Mdl\+::syscall\+\_\+args\+\_\+t\+::arg2}, \textbf{ Syscall\+Mdl\+::syscall\+\_\+args\+\_\+t\+::arg3}, \textbf{ Syscall\+Mdl\+::syscall\+\_\+args\+\_\+t\+::arg4}, \textbf{ Syscall\+Mdl\+::syscall\+\_\+args\+\_\+t\+::arg5}, \textbf{ Thread\+::clear\+\_\+tid}, \textbf{ Thread\+::get\+Syscall\+Mdl()}, \textbf{ local\+Store}, \textbf{ LOG\+\_\+\+ASSERT\+\_\+\+ERROR}, \textbf{ LOG\+\_\+\+PRINT}, \textbf{ LOG\+\_\+\+PRINT\+\_\+\+ERROR}, \textbf{ Thread\+::m\+\_\+os\+\_\+info}, \textbf{ Syscall\+Mdl\+::run\+Enter()}, and \textbf{ Thread\+::tid\+\_\+ptr}.



Referenced by \textbf{ Instruction\+Modeling\+::add\+Instruction\+Modeling()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_a067e6ebee2a1d430c96c627ddf6a39dd_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_a067e6ebee2a1d430c96c627ddf6a39dd_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!interceptSignal@{interceptSignal}}
\index{interceptSignal@{interceptSignal}!lite@{lite}}
\doxysubsubsection{interceptSignal()}
{\footnotesize\ttfamily \label{namespacelite_aa9c924b436d42ff966953cd070e6ffa6} 
bool lite\+::intercept\+Signal (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+Index}{, }\item[{INT32}]{signal}{, }\item[{CONTEXT $\ast$}]{ctx}{, }\item[{BOOL}]{has\+Handler}{, }\item[{const EXCEPTION\+\_\+\+INFO $\ast$}]{p\+Except\+Info}{, }\item[{void $\ast$}]{v}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 107} of file \textbf{ handle\+\_\+syscalls.\+cc}.



Referenced by \textbf{ main()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=215pt]{namespacelite_aa9c924b436d42ff966953cd070e6ffa6_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!mallocAfter@{mallocAfter}}
\index{mallocAfter@{mallocAfter}!lite@{lite}}
\doxysubsubsection{mallocAfter()}
{\footnotesize\ttfamily \label{namespacelite_a3ff4d13b8f6774742c0d9901c9a74f71} 
void lite\+::malloc\+After (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+\_\+id}{, }\item[{ADDRINT}]{address}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 363} of file \textbf{ routine\+\_\+replace.\+cc}.



References \textbf{ local\+Store}.



Referenced by \textbf{ routine\+Callback()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=336pt]{namespacelite_a3ff4d13b8f6774742c0d9901c9a74f71_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!mallocBefore@{mallocBefore}}
\index{mallocBefore@{mallocBefore}!lite@{lite}}
\doxysubsubsection{mallocBefore()}
{\footnotesize\ttfamily \label{namespacelite_a223c3d68b0d1126bf9e4f2e3782f7ea0} 
void lite\+::malloc\+Before (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+\_\+id}{, }\item[{ADDRINT}]{eip}{, }\item[{ADDRINT}]{size}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 357} of file \textbf{ routine\+\_\+replace.\+cc}.



References \textbf{ local\+Store}.



Referenced by \textbf{ routine\+Callback()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=343pt]{namespacelite_a223c3d68b0d1126bf9e4f2e3782f7ea0_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!nullFunction@{nullFunction}}
\index{nullFunction@{nullFunction}!lite@{lite}}
\doxysubsubsection{nullFunction()}
{\footnotesize\ttfamily \label{namespacelite_a1dea6947b7e6d45a17bf9a662cdd43ac} 
\textbf{ Int\+Ptr} lite\+::null\+Function (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 330} of file \textbf{ routine\+\_\+replace.\+cc}.



References \textbf{ LOG\+\_\+\+PRINT}.



Referenced by \textbf{ routine\+Callback()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=339pt]{namespacelite_a1dea6947b7e6d45a17bf9a662cdd43ac_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!printStackTrace@{printStackTrace}}
\index{printStackTrace@{printStackTrace}!lite@{lite}}
\doxysubsubsection{printStackTrace()}
{\footnotesize\ttfamily \label{namespacelite_ad983490d968de37a960a93c1a3209094} 
void lite\+::print\+Stack\+Trace (\begin{DoxyParamCaption}\item[{THREADID}]{threadid}{, }\item[{char $\ast$}]{function}{, }\item[{BOOL}]{enter}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 45} of file \textbf{ routine\+\_\+replace.\+cc}.



Referenced by \textbf{ routine\+Callback()}.

Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_ad983490d968de37a960a93c1a3209094_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!pthreadAfter@{pthreadAfter}}
\index{pthreadAfter@{pthreadAfter}!lite@{lite}}
\doxysubsubsection{pthreadAfter()}
{\footnotesize\ttfamily \label{namespacelite_a3c25b4df5c906e422d0e2d12ac1eedfb} 
void lite\+::pthread\+After (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+\_\+id}{, }\item[{ADDRINT}]{type\+\_\+id}{, }\item[{ADDRINT}]{retval}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 344} of file \textbf{ routine\+\_\+replace.\+cc}.



References \textbf{ Performance\+Model\+::get\+Elapsed\+Time()}, \textbf{ Core\+::get\+Performance\+Model()}, \textbf{ local\+Store}, \textbf{ pthread\+\_\+functions}, \textbf{ pthread\+\_\+t\+\_\+start}, \textbf{ lite\+::pthread\+\_\+functions\+\_\+t\+::state\+\_\+after}, \textbf{ Pthread\+Emu\+::\+STATE\+\_\+\+BY\+\_\+\+RETURN}, \textbf{ Pthread\+Emu\+::\+STATE\+\_\+\+INREGION}, \textbf{ Pthread\+Emu\+::\+STATE\+\_\+\+RUNNING}, and \textbf{ Subsecond\+Time\+::\+Zero()}.



Referenced by \textbf{ routine\+Callback()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_a3c25b4df5c906e422d0e2d12ac1eedfb_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=340pt]{namespacelite_a3c25b4df5c906e422d0e2d12ac1eedfb_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!pthreadBefore@{pthreadBefore}}
\index{pthreadBefore@{pthreadBefore}!lite@{lite}}
\doxysubsubsection{pthreadBefore()}
{\footnotesize\ttfamily \label{namespacelite_af047d369d5f2f95a2209de81cea1f3bf} 
void lite\+::pthread\+Before (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+\_\+id}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 336} of file \textbf{ routine\+\_\+replace.\+cc}.



References \textbf{ Performance\+Model\+::get\+Elapsed\+Time()}, \textbf{ Core\+::get\+Performance\+Model()}, \textbf{ local\+Store}, \textbf{ pthread\+\_\+t\+\_\+start}, and \textbf{ Pthread\+Emu\+::\+STATE\+\_\+\+WAITING}.



Referenced by \textbf{ routine\+Callback()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_af047d369d5f2f95a2209de81cea1f3bf_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=347pt]{namespacelite_af047d369d5f2f95a2209de81cea1f3bf_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!routineCallback@{routineCallback}}
\index{routineCallback@{routineCallback}!lite@{lite}}
\doxysubsubsection{routineCallback()}
{\footnotesize\ttfamily \label{namespacelite_a0e98aa1ef09d70454937b5d84aa87c04} 
void lite\+::routine\+Callback (\begin{DoxyParamCaption}\item[{RTN}]{rtn}{, }\item[{void $\ast$}]{v}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 66} of file \textbf{ routine\+\_\+replace.\+cc}.



References \textbf{ add\+Rtn\+Tracer()}, \textbf{ Pthread\+Emu\+::\+Barrier\+Init()}, \textbf{ Pthread\+Emu\+::\+Barrier\+Wait()}, \textbf{ Carbon\+Barrier\+Init()}, \textbf{ Carbon\+Barrier\+Wait()}, \textbf{ Carbon\+Cond\+Broadcast()}, \textbf{ Carbon\+Cond\+Init()}, \textbf{ Carbon\+Cond\+Signal()}, \textbf{ Carbon\+Cond\+Wait()}, \textbf{ Carbon\+Mutex\+Init()}, \textbf{ Carbon\+Mutex\+Lock()}, \textbf{ Carbon\+Mutex\+Unlock()}, \textbf{ Pthread\+Emu\+::\+Cond\+Broadcast()}, \textbf{ Pthread\+Emu\+::\+Cond\+Init()}, \textbf{ Pthread\+Emu\+::\+Cond\+Signal()}, \textbf{ Pthread\+Emu\+::\+Cond\+Wait()}, \textbf{ emu\+Clock\+Gettime()}, \textbf{ emu\+Get\+CPU()}, \textbf{ emu\+Get\+Nprocs()}, \textbf{ emu\+Gettimeofday()}, \textbf{ free\+Before()}, \textbf{ malloc\+After()}, \textbf{ malloc\+Before()}, \textbf{ Pthread\+Emu\+::\+Mutex\+Init()}, \textbf{ Pthread\+Emu\+::\+Mutex\+Lock()}, \textbf{ Pthread\+Emu\+::\+Mutex\+Trylock()}, \textbf{ Pthread\+Emu\+::\+Mutex\+Unlock()}, \textbf{ lite\+::pthread\+\_\+functions\+\_\+t\+::name}, \textbf{ null\+Function()}, \textbf{ print\+Stack\+Trace()}, \textbf{ pthread\+\_\+functions}, \textbf{ pthread\+After()}, \textbf{ pthread\+Before()}, and \textbf{ ptr\+\_\+exit}.



Referenced by \textbf{ main()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_a0e98aa1ef09d70454937b5d84aa87c04_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=217pt]{namespacelite_a0e98aa1ef09d70454937b5d84aa87c04_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!routineStartCallback@{routineStartCallback}}
\index{routineStartCallback@{routineStartCallback}!lite@{lite}}
\doxysubsubsection{routineStartCallback()}
{\footnotesize\ttfamily \label{namespacelite_ac0dcc4efee0b1512fc740de2f161d5bc} 
void lite\+::routine\+Start\+Callback (\begin{DoxyParamCaption}\item[{RTN}]{rtn}{, }\item[{INS}]{ins}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 50} of file \textbf{ routine\+\_\+replace.\+cc}.



References \textbf{ emu\+Kmp\+Reap\+Monitor()}.



Referenced by \textbf{ trace\+Callback()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=328pt]{namespacelite_ac0dcc4efee0b1512fc740de2f161d5bc_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=349pt]{namespacelite_ac0dcc4efee0b1512fc740de2f161d5bc_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!syscallEnterRunModel@{syscallEnterRunModel}}
\index{syscallEnterRunModel@{syscallEnterRunModel}!lite@{lite}}
\doxysubsubsection{syscallEnterRunModel()}
{\footnotesize\ttfamily \label{namespacelite_a2d7ba753e4e147f10dc8dbd5f3f91348} 
void lite\+::syscall\+Enter\+Run\+Model (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+Index}{, }\item[{CONTEXT $\ast$}]{ctx}{, }\item[{SYSCALL\+\_\+\+STANDARD}]{syscall\+\_\+standard}{, }\item[{void $\ast$}]{v}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 72} of file \textbf{ handle\+\_\+syscalls.\+cc}.



References \textbf{ Thread\+::get\+Syscall\+Mdl()}, \textbf{ Syscall\+Mdl\+::is\+Emulated()}, \textbf{ local\+Store}, and \textbf{ LOG\+\_\+\+ASSERT\+\_\+\+ERROR}.



Referenced by \textbf{ main()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=325pt]{namespacelite_a2d7ba753e4e147f10dc8dbd5f3f91348_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=246pt]{namespacelite_a2d7ba753e4e147f10dc8dbd5f3f91348_icgraph}
\end{center}
\end{figure}
\index{lite@{lite}!syscallExitRunModel@{syscallExitRunModel}}
\index{syscallExitRunModel@{syscallExitRunModel}!lite@{lite}}
\doxysubsubsection{syscallExitRunModel()}
{\footnotesize\ttfamily \label{namespacelite_a5524674620c4cbc19bee26918e4f155e} 
void lite\+::syscall\+Exit\+Run\+Model (\begin{DoxyParamCaption}\item[{THREADID}]{thread\+Index}{, }\item[{CONTEXT $\ast$}]{ctx}{, }\item[{SYSCALL\+\_\+\+STANDARD}]{syscall\+\_\+standard}{, }\item[{void $\ast$}]{v}{}\end{DoxyParamCaption})}



Definition at line \textbf{ 82} of file \textbf{ handle\+\_\+syscalls.\+cc}.



References \textbf{ Syscall\+Mdl\+::get\+Current\+Syscall\+Number()}, \textbf{ Thread\+::get\+Syscall\+Mdl()}, \textbf{ Syscall\+Mdl\+::is\+Emulated()}, \textbf{ local\+Store}, \textbf{ LOG\+\_\+\+ASSERT\+\_\+\+ERROR}, \textbf{ LOG\+\_\+\+PRINT}, \textbf{ Thread\+::m\+\_\+os\+\_\+info}, \textbf{ Syscall\+Mdl\+::run\+Exit()}, and \textbf{ Thread\+::tid}.



Referenced by \textbf{ main()}.

Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacelite_a5524674620c4cbc19bee26918e4f155e_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=240pt]{namespacelite_a5524674620c4cbc19bee26918e4f155e_icgraph}
\end{center}
\end{figure}


\doxysubsection{Variable Documentation}
\index{lite@{lite}!g\_atomic\_lock@{g\_atomic\_lock}}
\index{g\_atomic\_lock@{g\_atomic\_lock}!lite@{lite}}
\doxysubsubsection{g\_atomic\_lock}
{\footnotesize\ttfamily \label{namespacelite_ac405642298a4b65c5225fad1924fe7df} 
\textbf{ Lock} lite\+::g\+\_\+atomic\+\_\+lock}



Definition at line \textbf{ 18} of file \textbf{ memory\+\_\+modeling.\+cc}.



Referenced by \textbf{ complete\+Memory\+Write()}, \textbf{ handle\+Memory\+Read\+Faultinjection()}, and \textbf{ handle\+Memory\+Read\+Faultinjection\+Nondetailed()}.

\index{lite@{lite}!g\_zeros@{g\_zeros}}
\index{g\_zeros@{g\_zeros}!lite@{lite}}
\doxysubsubsection{g\_zeros}
{\footnotesize\ttfamily \label{namespacelite_a8dd9ee78b18f38f1bddd00dcab0c6816} 
char lite\+::g\+\_\+zeros[1024] = \{ 0 \}}



Definition at line \textbf{ 355} of file \textbf{ memory\+\_\+modeling.\+cc}.



Referenced by \textbf{ handle\+Memory\+Write\+Faultinjection()}.

\index{lite@{lite}!pthread\_functions@{pthread\_functions}}
\index{pthread\_functions@{pthread\_functions}!lite@{lite}}
\doxysubsubsection{pthread\_functions}
{\footnotesize\ttfamily \label{namespacelite_ac8afb8fb8e88b09e38078653f9f391e4} 
struct \textbf{ lite\+::pthread\+\_\+functions\+\_\+t} lite\+::pthread\+\_\+functions[$\,$]}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{=\ \{}
\DoxyCodeLine{\ \ \ \{\ \textcolor{stringliteral}{"{}pthread\_mutex\_lock"{}},\ \ \ \ \ \ PthreadEmu::PTHREAD\_MUTEX\_LOCK,\ \ \ \ \ PthreadEmu::STATE\_INREGION\ \},}
\DoxyCodeLine{\ \ \ \{\ \textcolor{stringliteral}{"{}pthread\_mutex\_trylock"{}},\ \ \ PthreadEmu::PTHREAD\_MUTEX\_TRYLOCK,\ \ PthreadEmu::STATE\_BY\_RETURN\ \},}
\DoxyCodeLine{\ \ \ \{\ \textcolor{stringliteral}{"{}pthread\_mutex\_unlock"{}},\ \ \ \ PthreadEmu::PTHREAD\_MUTEX\_UNLOCK,\ \ \ PthreadEmu::STATE\_RUNNING\ \},}
\DoxyCodeLine{\ \ \ \{\ \textcolor{stringliteral}{"{}pthread\_cond\_wait"{}},\ \ \ \ \ \ \ PthreadEmu::PTHREAD\_COND\_WAIT,\ \ \ \ \ \ PthreadEmu::STATE\_RUNNING\ \},}
\DoxyCodeLine{\ \ \ \{\ \textcolor{stringliteral}{"{}pthread\_cond\_signal"{}},\ \ \ \ \ PthreadEmu::PTHREAD\_COND\_SIGNAL,\ \ \ \ PthreadEmu::STATE\_RUNNING\ \},}
\DoxyCodeLine{\ \ \ \{\ \textcolor{stringliteral}{"{}pthread\_cond\_broadcast"{}},\ \ PthreadEmu::PTHREAD\_COND\_BROADCAST,\ PthreadEmu::STATE\_RUNNING\ \},}
\DoxyCodeLine{\ \ \ \{\ \textcolor{stringliteral}{"{}pthread\_barrier\_wait"{}},\ \ \ \ PthreadEmu::PTHREAD\_BARRIER\_WAIT,\ \ \ PthreadEmu::STATE\_RUNNING\ \},}
\DoxyCodeLine{\}}

\end{DoxyCode}


Referenced by \textbf{ pthread\+After()}, and \textbf{ routine\+Callback()}.

\index{lite@{lite}!pthread\_t\_start@{pthread\_t\_start}}
\index{pthread\_t\_start@{pthread\_t\_start}!lite@{lite}}
\doxysubsubsection{pthread\_t\_start}
{\footnotesize\ttfamily \label{namespacelite_aabea4717b505418d7a9eaff04f80f0cf} 
std\+::unordered\+\_\+map$<$\textbf{ core\+\_\+id\+\_\+t}, \textbf{ Subsecond\+Time}$>$ lite\+::pthread\+\_\+t\+\_\+start}



Definition at line \textbf{ 28} of file \textbf{ routine\+\_\+replace.\+cc}.



Referenced by \textbf{ pthread\+After()}, and \textbf{ pthread\+Before()}.

\index{lite@{lite}!ptr\_exit@{ptr\_exit}}
\index{ptr\_exit@{ptr\_exit}!lite@{lite}}
\doxysubsubsection{ptr\_exit}
{\footnotesize\ttfamily \label{namespacelite_ae3f2d3a03510b7530a5adc169edd0018} 
AFUNPTR lite\+::ptr\+\_\+exit = NULL}



Definition at line \textbf{ 29} of file \textbf{ routine\+\_\+replace.\+cc}.



Referenced by \textbf{ emu\+Kmp\+Reap\+Monitor()}, and \textbf{ routine\+Callback()}.

